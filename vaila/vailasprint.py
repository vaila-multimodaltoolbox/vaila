"""
Project: vailá Multimodal Toolbox
Script: vailasprint.py

Author: Paulo Roberto Pereira Santiago
Email: paulosantiago@usp.br
GitHub: https://github.com/vaila-multimodaltoolbox/vaila
Creation Date: 08 January 2026
Update Date: 09 January 2026
Version: 0.6.0

Description:
Analysis of sprint data (20m) from TOML files generated by vailá Tracker.
Processes multiple files in a batch, generating:
- HTML Report with vailá logo, frame images, and interactive-like tables.
- Excel and CSV data for each run.
- High-quality plots (Speed & Acceleration).
- Consolidated Database (CSV) of all processed runs.
- General Analysis Report (Ranking & Statistics).
- ydata-profiling Report (if installed).
- Video frame extraction (Start/End) using OpenCV (Robust search).

Modes:
- Time Sprint20m: Linear sprint analysis.
- COD 90degree 20m: Change of Direction analysis (Planned).
"""

import os
import sys
import toml
import glob
import base64
import warnings
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog

try:
    import cv2
except ImportError:
    cv2 = None
    print("Warning: opencv-python not found. Video frame extraction will be disabled.")

try:
    from ydata_profiling import ProfileReport
    HAS_PROFILING = True
except ImportError:
    HAS_PROFILING = False
    print("Warning: ydata-profiling not found. Statistical profiling will be disabled.")

# Set plot style for better aesthetics
sns.set_theme(style="whitegrid", context="talk")


def get_reference_data():
    """Returns the reference data for comparison."""
    data = {
        "Atleta": ["Usain Bolt (WR 100m Avg)", "Usain Bolt (Max Speed)", "Gabriel Silva (Recorde Futebol)"],
        "Speed (km/h)": [37.58, 44.72, 40.30],
        "Speed (m/s)": [10.44, 12.42, 11.19],
        "Detalhes": ["Average speed during 9.58s WR", "Top momentary speed recorded", "Sta Clara vs Famalicão (GPS) - May 2025"]
    }
    return pd.DataFrame(data)


def get_logo_base64():
    """Reads the vailá logo and returns a base64 string."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    candidates = [
        os.path.join(script_dir, "images", "vaila.png"),
        os.path.join(script_dir, "..", "docs", "images", "vaila.png"),
        os.path.join(script_dir, "..", "..", "docs", "images", "vaila.png"),
    ]
    
    for path in candidates:
        if os.path.exists(path):
            try:
                with open(path, "rb") as image_file:
                    return base64.b64encode(image_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Error reading logo {path}: {e}")
                return None
    return None


def extract_frame(video_path, frame_number, output_path):
    """Extracts a specific frame from a video and saves it as an image."""
    if cv2 is None:
        return False
        
    try:
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            return False
            
        # Get total frames to ensure frame_number is valid
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        if total_frames <= 0:
            return False

        if frame_number >= total_frames:
            frame_number = total_frames - 1
            
        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
        ret, frame = cap.read()
        cap.release()
        
        if ret:
            cv2.imwrite(output_path, frame)
            return True
        else:
            return False
    except Exception as e:
        print(f"Exception extracting frame from {video_path}: {e}")
        return False


def get_video_and_frame_indices(cut_data, root_data, input_dir):
    """
    Determines the best video file path and frame indices (start, end)
    to extract for a given cut.
    """
    
    # Strategy 1: Look for the specific CUT video file
    # Normalize path separators to ensure correct basename extraction across OSs
    raw_cut_path = cut_data.get('output_file', '')
    cut_file_name = os.path.basename(raw_cut_path.replace('\\', '/'))
    cut_video_path = os.path.join(input_dir, cut_file_name)
    
    if cut_file_name and os.path.exists(cut_video_path):
        frame_count = cut_data.get('frame_count', 1)
        return cut_video_path, 0, frame_count - 1
        
    # Strategy 2: Look for the SOURCE video file
    raw_source_path = root_data.get('source_file', '')
    source_file_name = os.path.basename(raw_source_path.replace('\\', '/'))
    
    candidates = [
        raw_source_path, 
        os.path.join(input_dir, source_file_name)
    ]
    
    source_video_path = None
    for cand in candidates:
        if cand and os.path.exists(cand):
            source_video_path = cand
            break
            
    if source_video_path:
        start_frame = cut_data.get('start_frame', 0)
        end_frame = cut_data.get('end_frame', 0)
        return source_video_path, start_frame, end_frame
        
    return None, None, None


def process_sprint_file(filepath, output_base_dir, logo_b64):
    """
    Processes a single TOML file and returns summary data for the database.
    """
    print(f"Processing: {filepath}")
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = toml.load(f)
            
        if "cuts" not in data:
            print(f"Skipping {filepath}: 'cuts' key not found.")
            return []

        cuts = data["cuts"]
        df = pd.DataFrame(cuts)

        if df.empty:
             print(f"Skipping {filepath}: No cuts data.")
             return []

        # Prepare output directory
        file_basename = os.path.splitext(os.path.basename(filepath))[0]
        # Extract Athlete Name: everything before the first underscore in basename
        athlete_name = file_basename.split('_')[0]
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = os.path.join(output_base_dir, f"{file_basename}_analysis_{timestamp}")
        os.makedirs(output_dir, exist_ok=True)
        
        # --- Calculations ---
        SECTION_DISTANCE = 5.0  # meters
        CUTS_PER_RUN = 4
        
        df['run_id'] = ((df['index'] - 1) // CUTS_PER_RUN) + 1
        df['distance_cumulative'] = df.groupby('run_id').cumcount() * SECTION_DISTANCE + SECTION_DISTANCE
        df['speed_ms'] = SECTION_DISTANCE / df['duration']
        df['speed_kmh'] = df['speed_ms'] * 3.6
        df['prev_speed_ms'] = df.groupby('run_id')['speed_ms'].shift(1).fillna(0)
        df['acceleration_ms2'] = (df['speed_ms'] - df['prev_speed_ms']) / df['duration']
        
        # --- Reports Generation ---
        runs = df['run_id'].unique()
        
        summary_lines = [f"Analysis Report for {athlete_name} ({file_basename})", "="*40, ""]
        html_sections = []
        database_rows = []

        # Logo HTML
        logo_html = ""
        if logo_b64:
            logo_html = f'<div style="text-align: center; margin-bottom: 20px;"><img src="data:image/png;base64,{logo_b64}" width="120"></div>'

        for rid in runs:
            df_run = df[df['run_id'] == rid].copy()
            prefix = f"{athlete_name}_Run_{rid}"
            
            # Metrics
            total_time = df_run['duration'].sum()
            max_spd_kmh = df_run['speed_kmh'].max()
            max_spd_ms = df_run['speed_ms'].max()
            max_acc = df_run['acceleration_ms2'].max()
            
            summary_lines.extend([
                f"Run {rid}:",
                f"  Total Time (20m): {total_time:.3f} s",
                f"  Max Speed:        {max_spd_kmh:.2f} km/h ({max_spd_ms:.2f} m/s)",
                f"  Peak Acceleration: {max_acc:.2f} m/s²",
                "-"*20
            ])
            
            # --- Frame Extraction Logic (0, 5, 10, 15, 20m) ---
            frame_imgs_html = ""
            if cv2: 
                input_dir = os.path.dirname(filepath)
                frames_to_extract = []

                # 1. Start (0m) - Start of first cut
                if not df_run.empty:
                    frames_to_extract.append({
                        "dist_label": "0m",
                        "cut_idx": df_run.index[0],
                        "use_end_frame": False
                    })

                # 2. Ends (5m, 10m, 15m, 20m...)
                # Aggregating based on cuts in the run
                current_dist = 0
                for idx_in_run, cut_idx in enumerate(df_run.index):
                    current_dist += SECTION_DISTANCE
                    frames_to_extract.append({
                        "dist_label": f"{int(current_dist)}m",
                        "cut_idx": cut_idx,
                        "use_end_frame": True
                    })

                valid_frames_count = 0
                for item in frames_to_extract:
                    cut_data = cuts[item['cut_idx']]
                    vid_path, frame_start, frame_end = get_video_and_frame_indices(cut_data, data, input_dir)
                    
                    if vid_path:
                        target_frame = frame_end if item['use_end_frame'] else frame_start
                        label = item['dist_label']
                        img_name = f"{prefix}_{label}.png"
                        img_path = os.path.join(output_dir, img_name)
                        
                        if extract_frame(vid_path, target_frame, img_path):
                            frame_imgs_html += f'''
                            <div style="text-align: center;">
                                <img src="{os.path.basename(img_path)}" height="150" style="border: 1px solid #ddd; border-radius: 4px; cursor: pointer;" onclick="openModal(this)" alt="{label}"><br>
                                <strong>{label}</strong>
                            </div>
                            '''
                            valid_frames_count += 1
                
                if valid_frames_count == 0:
                     frame_imgs_html = "<div style='color: gray; font-style: italic;'>No video frames extracted (Check video file names)</div>"
            
            
            # --- Enhanced Plotting ---
            # Speed Plot
            plt.figure(figsize=(10, 6))
            sns.lineplot(data=df_run, x='distance_cumulative', y='speed_kmh', marker='o', linewidth=3, label=athlete_name)
            
            # Updated Reference Line (Usain Bolt - Dual)
            plt.axhline(y=37.58, color='gold', linestyle='--', linewidth=2, label='Bolt Avg (37.58 km/h)')
            plt.axhline(y=44.72, color='red', linestyle=':', linewidth=2, label='Bolt Max (44.72 km/h)')
            
            max_v_idx = df_run['speed_kmh'].idxmax()
            max_v_x = df_run.loc[max_v_idx, 'distance_cumulative']
            max_v_y = df_run.loc[max_v_idx, 'speed_kmh']
            plt.annotate(f'Max: {max_v_y:.1f} km/h', 
                         xy=(max_v_x, max_v_y), xytext=(max_v_x, max_v_y + 2),
                         arrowprops=dict(facecolor='black', shrink=0.05))
            
            plt.title(f"Speed Profile - Run {rid} ({athlete_name})", fontsize=16, fontweight='bold')
            plt.xlabel("Distance (m)", fontsize=12)
            plt.ylabel("Speed (km/h)", fontsize=12)
            plt.ylim(bottom=0)
            plt.legend(loc='lower right')
            vel_plot_path = os.path.join(output_dir, f"{prefix}_speed.png")
            plt.savefig(vel_plot_path, bbox_inches='tight', dpi=150)
            plt.close()

            # Acceleration Plot
            plt.figure(figsize=(10, 6))
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                bar_plot = sns.barplot(data=df_run, x='distance_cumulative', y='acceleration_ms2', hue='distance_cumulative', palette='viridis', legend=False)
            
            plt.title(f"Acceleration per Section - Run {rid} ({athlete_name})", fontsize=16, fontweight='bold')
            plt.xlabel("Distance (m)", fontsize=12)
            plt.ylabel("Acceleration (m/s²)", fontsize=12)
            
            for p in bar_plot.patches:
                bar_plot.annotate(f'{p.get_height():.2f}', 
                                  (p.get_x() + p.get_width() / 2., p.get_height()), 
                                  ha='center', va='center', xytext=(0, 10), textcoords='offset points')
                                  
            acc_plot_path = os.path.join(output_dir, f"{prefix}_acceleration.png")
            plt.savefig(acc_plot_path, bbox_inches='tight', dpi=150)
            plt.close()
            
            # Save CSV/Excel
            cols_export = ['distance_cumulative', 'duration', 'speed_ms', 'speed_kmh', 'acceleration_ms2']
            df_run[cols_export].to_excel(os.path.join(output_dir, f"{prefix}_data.xlsx"), index=False)
            df_run[cols_export].to_csv(os.path.join(output_dir, f"{prefix}_data.csv"), index=False)
            
            # HTML Section
            html_sections.append(f"""
            <div class="run-section">
                <h2 style="color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px;">Run {rid} Analysis</h2>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; background: #ecf0f1; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #7f8c8d;">Total Time (20m)</div>
                        <div style="font-size: 1.5em; font-weight: bold; color: #2c3e50;">{total_time:.3f} s</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #7f8c8d;">Max Speed</div>
                        <div style="font-size: 1.5em; font-weight: bold; color: #e74c3c;">{max_spd_kmh:.2f} km/h</div>
                        <div style="font-size: 0.8em; color: #95a5a6;">{max_spd_ms:.2f} m/s</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #7f8c8d;">Peak Acceleration</div>
                        <div style="font-size: 1.5em; font-weight: bold; color: #f39c12;">{max_acc:.2f} m/s²</div>
                    </div>
                </div>

                <div class="frames-container" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-bottom: 30px;">
                    {frame_imgs_html}
                </div>

                <div class="plots" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
                    <img src="{os.path.basename(vel_plot_path)}" width="45%" style="box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px;">
                    <img src="{os.path.basename(acc_plot_path)}" width="45%" style="box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px;">
                </div>
                
                <h3 style="margin-top: 30px; color: #34495e;">Interval Data</h3>
                {df_run[cols_export].to_html(classes='data-table', float_format='%.3f', index=False)}
                <br>
            </div>
            """)
            
            # Database Record
            for idx, row in df_run.iterrows():
                cut_row = {
                    'file_name': file_basename,
                    'athlete_name': athlete_name,
                    'patient_id': athlete_name,
                    'run_id': rid,
                    'distance_m': row['distance_cumulative'],
                    'duration_s': row['duration'],
                    'speed_ms': row['speed_ms'],
                    'speed_kmh': row['speed_kmh'],
                    'acceleration_ms2': row['acceleration_ms2'],
                    'date_processed': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                }
                database_rows.append(cut_row)

        with open(os.path.join(output_dir, "summary.txt"), "w", encoding='utf-8') as f:
            f.write("\n".join(summary_lines))
            
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Sprint Analysis - {athlete_name}</title>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 40px; background-color: #f9f9f9; color: #333; }}
                .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 40px; box-shadow: 0 0 20px rgba(0,0,0,0.05); border-radius: 10px; }}
                h1 {{ text-align: center; color: #2c3e50; margin-bottom: 10px; }}
                .meta-info {{ text-align: center; color: #7f8c8d; margin-bottom: 40px; }}
                .data-table {{ border-collapse: collapse; width: 100%; margin: 20px 0; font-size: 0.9em; }}
                .data-table th, .data-table td {{ border: 1px solid #e0e0e0; padding: 12px 15px; text-align: center; }}
                .data-table th {{ background-color: #3498db; color: white; text-transform: uppercase; letter-spacing: 0.03em; }}
                .data-table tr:nth-child(even) {{ background-color: #f8f9fa; }}
                .data-table tr:hover {{ background-color: #f1f1f1; }}
                hr {{ border: 0; height: 1px; background: #e0e0e0; margin: 40px 0; }}
                
                /* Lightbox Modal */
                .modal {{ display: none; position: fixed; z-index: 1000; padding-top: 50px; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.9); }}
                .modal-content {{ margin: auto; display: block; max-width: 90%; max-height: 90%; animation-name: zoom; animation-duration: 0.6s; }}
                @keyframes zoom {{ from {{transform:scale(0)}} to {{transform:scale(1)}} }}
                .close {{ position: absolute; top: 15px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; transition: 0.3s; cursor: pointer; }}
                .close:hover, .close:focus {{ color: #bbb; text-decoration: none; cursor: pointer; }}
            </style>
            <script>
                function openModal(img) {{
                    var modal = document.getElementById("myModal");
                    var modalImg = document.getElementById("img01");
                    modal.style.display = "block";
                    modalImg.src = img.src;
                }}
                function closeModal() {{
                    document.getElementById("myModal").style.display = "none";
                }}
                
                // Close on Escape key
                document.addEventListener('keydown', function(event) {{
                    if (event.key === "Escape") {{
                        closeModal();
                    }}
                }});
            </script>
        </head>
        <body>
            <div class="container">
                {logo_html}
                <h1><i>vailá</i> Sprint 20mAnalysis - {athlete_name}</h1>
                <div class="meta-info">
                    <p><strong>File:</strong> {file_basename} | <strong>Date:</strong> {datetime.now().strftime("%d/%m/%Y %H:%M:%S")}</p>
                </div>
                
                {''.join(html_sections)}
                
                <h2>Reference Values</h2>
                {get_reference_data().to_html(classes='data-table', index=False)}
            </div>
            
            <!-- Lightbox Modal -->
            <div id="myModal" class="modal" onclick="closeModal()">
              <span class="close">&times;</span>
              <img class="modal-content" id="img01">
            </div>

        </body>
        </html>
        """
        with open(os.path.join(output_dir, f"{file_basename}_report_sprint20m.html"), "w", encoding='utf-8') as f:
            f.write(html_content)

        print(f"Finished {file_basename} -> Output: {output_dir}")
        return database_rows

    except Exception as e:
        print(f"Error processing {filepath}: {e}")
        import traceback
        traceback.print_exc()
        return []


def generate_general_report(all_data, output_dir, logo_b64):
    """Generates a general report with ranking and a consolidated database."""
    if not all_data:
        return
        
    df = pd.DataFrame(all_data)
    
    # 1. Consolidated Database
    db_path = os.path.join(output_dir, "vaila_sprint_database.csv")
    df.to_csv(db_path, index=False)
    print(f"Database generated: {db_path}")

    # 2. Ranking Summary
    run_stats = df.groupby(['athlete_name', 'file_name', 'run_id']).agg({
        'speed_kmh': 'max',
        'duration_s': 'sum'
    }).reset_index()
    
    run_stats.rename(columns={'speed_kmh': 'max_speed_kmh', 'duration_s': 'total_time_s'}, inplace=True)
    
    ranking_speed = run_stats.sort_values(by='max_speed_kmh', ascending=False).reset_index(drop=True)
    ranking_speed.index += 1 
    
    ranking_time = run_stats.sort_values(by='total_time_s', ascending=True).reset_index(drop=True)
    ranking_time.index += 1

    # 3. ydata-profiling
    if HAS_PROFILING:
        print("Generating ydata-profiling report... (This may take a moment)")
        try:
            profile = ProfileReport(df, title="vailá Sprint - Statistical Profiling Report", minimal=True) 
            profile.to_file(os.path.join(output_dir, "vaila_sprint_profiling.html"))
        except Exception as e:
            print(f"Error generating profiling report: {e}")

    # 4. General HTML Report
    logo_html = ""
    if logo_b64:
        logo_html = f'<div style="text-align: center; margin-bottom: 20px;"><img src="data:image/png;base64,{logo_b64}" width="120"></div>'
    
    plt.figure(figsize=(12, 6))
    sns.barplot(data=run_stats, x='athlete_name', y='max_speed_kmh', hue='run_id', palette='rocket')
    plt.title("Comparison of Max Speed by Athlete")
    plt.ylabel("Max Speed (km/h)")
    plt.xticks(rotation=45)
    comp_plot_path = os.path.join(output_dir, "comparison_max_speed.png")
    plt.savefig(comp_plot_path, bbox_inches='tight')
    plt.close()

    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>vailá Sprint - General Analysis</title>
        <meta charset="UTF-8">
        <style>
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 40px; background-color: #f9f9f9; color: #333; }}
            .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 40px; box-shadow: 0 0 20px rgba(0,0,0,0.05); border-radius: 10px; }}
            h1, h2 {{ text-align: center; color: #2c3e50; }}
            .data-table {{ border-collapse: collapse; width: 100%; margin: 20px 0; font-size: 0.9em; }}
            .data-table th, .data-table td {{ border: 1px solid #e0e0e0; padding: 12px 15px; text-align: center; }}
            .data-table th {{ background-color: #3498db; color: white; }}
            .data-table tr:nth-child(even) {{ background-color: #f8f9fa; }}
            .btn {{ display: inline-block; padding: 10px 20px; background: #27ae60; color: white; text-decoration: none; border-radius: 5px; margin: 5px; }}
        </style>
    </head>
    <body>
        <div class="container">
            {logo_html}
            <h1><i>vailá</i> Sprint - General Analysis Report</h1>
            <p style="text-align: center;"><strong>Processed:</strong> {len(all_data)} data points from {run_stats.shape[0]} runs.</p>
            
            <div style="text-align: center; margin: 20px;">
                <a href="vaila_sprint_profiling.html" class="btn" target="_blank">View Statistical Profiling</a>
                <a href="vaila_sprint_database.csv" class="btn">Download Database CSV</a>
            </div>

            <h2>Run Comparison</h2>
            <div style="text-align: center;">
                <img src="{os.path.basename(comp_plot_path)}" width="80%" style="border: 1px solid #ccc;">
            </div>

            <h2>Ranking: Max Speed (Fastest First)</h2>
            {ranking_speed[['athlete_name', 'run_id', 'max_speed_kmh', 'total_time_s']].to_html(classes='data-table', float_format='%.2f')}

            <h2>Ranking: Total Time (Fastest First)</h2>
            {ranking_time[['athlete_name', 'run_id', 'total_time_s', 'max_speed_kmh']].to_html(classes='data-table', float_format='%.3f')}
            
        </div>
    </body>
    </html>
    """
    
    with open(os.path.join(output_dir, "general_report.html"), "w", encoding='utf-8') as f:
        f.write(html_content)
    print(f"General Report generated: {os.path.join(output_dir, 'general_report.html')}")


def main():
    root = tk.Tk()
    root.withdraw()

    # --- Mode Selection ---
    
    # Custom Dialog for clearer options
    class ModeSelectionDialog(tk.Toplevel):
        def __init__(self, parent):
            super().__init__(parent)
            self.title("Select Analysis Mode")
            self.geometry("300x150")
            self.result = None
            
            tk.Label(self, text="Choose Sprint Analysis Mode:", font=("Arial", 12)).pack(pady=10)
            
            tk.Button(self, text="Time Sprint (20m)", width=25, command=self.set_sprint).pack(pady=5)
            tk.Button(self, text="COD 90 Degree (20m)", width=25, command=self.set_cod).pack(pady=5)
            
            self.protocol("WM_DELETE_WINDOW", self.on_close)
            
        def set_sprint(self):
            self.result = "sprint"
            self.destroy()
            
        def set_cod(self):
            self.result = "cod"
            self.destroy()
            
        def on_close(self):
            self.result = None
            self.destroy()

    dialog = ModeSelectionDialog(root)
    root.wait_window(dialog)
    mode = dialog.result
    
    if not mode:
        print("Operation cancelled.")
        return
        
    if mode == "cod":
        messagebox.showinfo("Coming Soon", "COD 90 Degree Analysis is planned for specific release.\nStay tuned!")
        return

    # --- Sprint Mode ---
    
    print("Select a directory containing TOML files...")
    input_dir = filedialog.askdirectory(title="Select Directory with TOML files")
    
    if not input_dir:
        print("No directory selected.")
        return

    toml_files = glob.glob(os.path.join(input_dir, "*.toml"))
    
    if not toml_files:
        messagebox.showinfo("vailá Sprint", "No .toml files found in the selected directory.")
        return

    output_base_dir = os.path.join(input_dir, "vaila_sprint_reports")
    os.makedirs(output_base_dir, exist_ok=True)
    
    logo_b64 = get_logo_base64()
    if not logo_b64:
        print("Logo not found (checked standard locations). Report will be plain.")
    
    print(f"Found {len(toml_files)} TOML files. Processing...")
    
    all_database_rows = []
    count = 0
    for f in toml_files:
        rows = process_sprint_file(f, output_base_dir, logo_b64)
        if rows:
            all_database_rows.extend(rows)
            count += 1
            
    # Generate General Report & Database
    if all_database_rows:
        generate_general_report(all_database_rows, output_base_dir, logo_b64)
    else:
        print("No valid data processed. Skipping General Report.")
        
    messagebox.showinfo("Success", f"Processed {count} files.\nReports saved in:\n{output_base_dir}")
    webbrowser_open = messagebox.askyesno("Open Output?", "Do you want to open the output directory?")
    
    if webbrowser_open:
        if sys.platform == 'win32':
            os.startfile(output_base_dir)
        elif sys.platform == 'darwin':
            os.system(f'open "{output_base_dir}"')
        else:
            os.system(f'xdg-open "{output_base_dir}"')

if __name__ == "__main__":
    main()