"""
================================================================================
Project: vailá Multimodal Toolbox
Script: vailasprint.py

Author: Paulo Roberto Pereira Santiago
Email: paulosantiago@usp.br
GitHub: https://github.com/vaila-multimodaltoolbox/vaila
Creation Date: 08 January 2026
Update Date: 25 February 2026
Version: 0.0.8
================================================================================

Description:
    This script is a comprehensive biomechanical and performance analysis tool
    for 20-meter linear sprints and Change of Direction (COD 180 degree) tests
    using data collected by the vailá Tracker.

    It is designed to automatically process multiple runs from TOML files,
    generate visual reports, and compile a database for team-wide analysis.

Features:
    - Batch processing of multiple TOML files from vailá Tracker
    - Individual athlete reports with speed and acceleration plots
    - Frame extraction from videos at key positions (0m, 5m, 10m, 15m, 20m)
    - Consolidated database (CSV) of all processed runs
    - General team report with:
        * Top performer identification (speed and time)
        * Team statistics (mean, std, min, max)
        * Visual performance analysis (dumbbell chart, scatter plot, heatmap)
        * K-means clustering (3 levels: High, Medium, Low performers)
        * Beeswarm plot for cluster visualization
        * Z-score analysis table with color-coded performance
        * Performance rankings (by speed and time)
    - Support for Sprint (20m linear) and COD (10m with 180 degree turn) modes

Analysis Modes:
    1. Time Sprint 20m: Linear sprint analysis with 4 sections (5m each)
    2. COD 180°: Change of Direction test (total 20m distance)

Input:
    - Directory containing TOML files generated by vailá Tracker
    - Each TOML file contains cut data with timing information

Output:
    For each athlete:
        - {athlete}_report_sprint20m.html: Individual HTML report
        - {athlete}_Run_N_speed.png: Speed profile plot
        - {athlete}_Run_N_acceleration.png: Acceleration plot
        - {athlete}_Run_N_data.xlsx/.csv: Raw data export
        - Frame images at each distance marker

    General report (team analysis):
        - general_report.html: Comprehensive team analysis
        - vaila_sprint_database.csv: Consolidated database
        - dumbbell_chart_performance.png: Run comparison chart
        - scatter_improvement_analysis.png: Improvement scatter plot
        - heatmap_performance_matrix.png: Performance matrix
        - beeswarm_cluster_plot.png: Cluster distribution

Dependencies:
    Required:
        - pandas, numpy, matplotlib, seaborn
        - scipy (for Z-score calculations)
        - toml (for reading TOML files)
        - tkinter (for GUI dialogs)

    Optional:
        - opencv-python (cv2): For video frame extraction
        - scikit-learn: For K-means clustering analysis

How to run:
    From command line:
        python vailasprint.py

    From vaila GUI:
        Access through the Sprint Analysis button

Example workflow:
    1. Run the script
    2. Select analysis mode (Sprint 20m or COD 180)
    3. Select directory containing TOML files
    4. Wait for processing
    5. Open the output directory to view reports

License:
    This script is distributed under the AGPL3 License
================================================================================
"""

import base64
import glob
import json
import os
import re
from pathlib import Path
import tkinter as tk
import time
import warnings
from datetime import datetime
from tkinter import filedialog, messagebox

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import toml
from rich import print

try:
    import cv2
except ImportError:
    cv2 = None
    print("Warning: opencv-python not found. Video frame extraction will be disabled.")

try:
    from sklearn.cluster import KMeans
    from sklearn.preprocessing import StandardScaler

    HAS_SKLEARN = True
except ImportError:
    HAS_SKLEARN = False
    print("Warning: scikit-learn not found. K-means clustering will be disabled.")

from scipy import stats

# Set plot style for better aesthetics
sns.set_theme(style="whitegrid", context="talk")

# Reference speeds for Usain Bolt
BOLT_AVG_SPEED = 37.58  # km/h - Average speed during 9.58s WR
BOLT_MAX_SPEED = 44.72  # km/h - Top momentary speed recorded


def _sanitize_filename_part(s):
    """Return a safe filename segment: only letters, digits, underscores (no spaces/parentheses)."""
    s = re.sub(r"[^a-zA-Z0-9_]", "_", str(s))
    return re.sub(r"_+", "_", s).strip("_") or "segment"


def create_dumbbell_chart(run_stats, output_dir):
    """
    Create a multi-run speed evolution chart per athlete.

    Returns the path to the saved figure.
    """
    pivot_speed = run_stats.pivot_table(
        index="athlete_name", columns="run_id", values="max_speed_kmh", aggfunc="first"
    )
    if pivot_speed.empty:
        print("Warning: No data available for run evolution chart.")
        return None

    run_ids = sorted([int(col) for col in pivot_speed.columns])
    if not run_ids:
        print("Warning: No run IDs available for run evolution chart.")
        return None

    pivot_speed = pivot_speed.reindex(columns=run_ids)
    pivot_speed["best_speed"] = pivot_speed.max(axis=1)
    pivot_speed = pivot_speed.sort_values("best_speed", ascending=False)

    r1 = run_ids[0]
    r2 = run_ids[-1] if len(run_ids) > 1 else run_ids[0]
    # Always show Run 1 vs Last Run dumbbell when we have at least 2 runs (same figure as COD).
    at_least_two = len(run_ids) >= 2 and pivot_speed[r1].notna().any() and pivot_speed[r2].notna().any()
    two_runs = len(run_ids) == 2 and at_least_two

    if len(run_ids) > 2:
        # Multi-run Dot Plot: base line + colors for each run
        fig_height = max(8, len(pivot_speed) * 0.45 + 2)
        fig, ax = plt.subplots(figsize=(14, fig_height))
        
        colors = sns.color_palette("husl", len(run_ids))
        y_pos = np.arange(len(pivot_speed))
        
        for i, (athlete, row) in enumerate(pivot_speed.iterrows()):
            valid_speeds = row.dropna().values
            if len(valid_speeds) == 0:
                continue
            
            min_spd = np.min(valid_speeds)
            max_spd = np.max(valid_speeds)
            
            # Base horizontal line segment for the athlete's speed amplitude
            ax.plot([min_spd, max_spd], [y_pos[i], y_pos[i]], color="#bdc3c7", linewidth=3, zorder=1)
            
            # Points for each run
            for color_idx, rid in enumerate(run_ids):
                spd = row.get(rid)
                if pd.notna(spd):
                    ax.scatter(spd, y_pos[i], s=120, c=[colors[color_idx]], 
                               edgecolors="white", linewidths=1.5, zorder=3, label=None)

        ax.set_yticks(y_pos)
        ax.set_yticklabels(pivot_speed.index, fontsize=9)
        ax.set_xlabel("Max Speed (km/h)", fontsize=12, fontweight="bold")
        ax.set_ylabel("Athlete", fontsize=12, fontweight="bold")
        ax.set_title(
            "Multi-Run Performance Distribution\nAthletes sorted by best overall speed.",
            fontsize=14,
            fontweight="bold",
            pad=18,
        )
        ax.grid(True, axis="x", linestyle="-", alpha=0.3)
        
        # Build dynamic legend
        legend_elements = []
        for color_idx, rid in enumerate(run_ids):
            legend_elements.append(
                plt.Line2D([0], [0], marker="o", color="w", markerfacecolor=colors[color_idx], 
                           markersize=10, label=f"Run {rid}")
            )
        ax.legend(handles=legend_elements, loc="center left", bbox_to_anchor=(1.02, 0.5), fontsize=9, framealpha=0.9)
        fig.subplots_adjust(right=0.82)
        
        output_path = os.path.join(output_dir, "dumbbell_chart_performance.png")
        fig.savefig(output_path, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
        plt.close(fig)
        print(f"Multi-run dot plot saved: {output_path}")
        
        # Evolution path is now handled by this single multi-run chart, 
        # so we don't need a separate evolution chart returned.
        return (output_path, None)

    elif at_least_two:
        # Classic Run 1 vs Run 2 dumbbell: one row per athlete, x = speed, segment connects Run1/Run2 dots.
        df2 = pivot_speed[[r1, r2]].dropna(how="any")
        if df2.empty:
            at_least_two = False
            two_runs = False
        else:
            athletes = df2.index.tolist()
            speed1 = df2[r1].values
            speed2 = df2[r2].values
            y_pos = np.arange(len(athletes))
            fig_height = max(8, len(athletes) * 0.45 + 2)
            fig, ax = plt.subplots(figsize=(14, fig_height))
            for i in range(len(athletes)):
                color = "#2ecc71" if speed2[i] > speed1[i] else "#e74c3c" if speed2[i] < speed1[i] else "#95a5a6"
                ax.plot([speed1[i], speed2[i]], [y_pos[i], y_pos[i]], color=color, linewidth=2.5, zorder=1)
                ax.scatter(speed1[i], y_pos[i], s=80, c="#3498db", edgecolors="white", linewidths=1.5, zorder=2, label=None)
                ax.scatter(speed2[i], y_pos[i], s=80, c="#e67e22", edgecolors="white", linewidths=1.5, zorder=2, label=None)
            ax.set_yticks(y_pos)
            ax.set_yticklabels(athletes, fontsize=9)
            ax.set_xlabel("Max Speed (km/h)", fontsize=12, fontweight="bold")
            ax.set_ylabel("Athlete", fontsize=12, fontweight="bold")
            ax.set_title(
                f"Performance Ranking: Run {r1} vs Run {r2}\nAthletes sorted by best speed. Green = improved, Red = declined.",
                fontsize=14,
                fontweight="bold",
                pad=18,
            )
            ax.grid(True, axis="x", linestyle="-", alpha=0.3)
            legend_elements = [
                plt.Line2D([0], [0], color="#2ecc71", linewidth=2.5, label="Improved"),
                plt.Line2D([0], [0], color="#e74c3c", linewidth=2.5, label="Declined"),
                plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#3498db", markersize=8, label=f"Run {r1}"),
                plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#e67e22", markersize=8, label=f"Run {r2}"),
            ]
            ax.legend(handles=legend_elements, loc="center left", bbox_to_anchor=(1.02, 0.5), fontsize=9, framealpha=0.9)
            fig.subplots_adjust(right=0.82)
            output_path = os.path.join(output_dir, "dumbbell_chart_performance.png")
            fig.savefig(output_path, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
            plt.close(fig)
            print(f"Run evolution chart saved: {output_path}")
            return (output_path, None)

    if not at_least_two:
        fig_height = max(8, len(pivot_speed) * 0.45 + 2)
        fig, ax = plt.subplots(figsize=(14, fig_height))
        colors = plt.cm.tab20(np.linspace(0, 1, max(len(pivot_speed), 2)))
        for idx, (athlete, row) in enumerate(pivot_speed.iterrows()):
            valid = row.drop(labels=["best_speed"]).dropna()
            if valid.empty:
                continue
            x_vals = [int(x) for x in valid.index]
            y_vals = valid.values.astype(float)
            ax.plot(
                x_vals,
                y_vals,
                marker="o",
                linewidth=2.2,
                markersize=6,
                color=colors[idx % len(colors)],
                alpha=0.85,
                label=athlete,
            )
        ax.set_xlabel("Run", fontsize=12, fontweight="bold")
        ax.set_ylabel("Max Speed (km/h)", fontsize=12, fontweight="bold")
        ax.set_title(
            "Performance Evolution Across Runs\n(Max Speed per Athlete)",
            fontsize=14,
            fontweight="bold",
            pad=18,
        )
        ax.set_xticks(run_ids)
        ax.grid(True, linestyle="-", alpha=0.3)
        ax.legend(loc="center left", bbox_to_anchor=(1.02, 0.5), fontsize=8, framealpha=0.9)
        fig.subplots_adjust(right=0.78)
        output_path = os.path.join(output_dir, "dumbbell_chart_performance.png")
        fig.savefig(output_path, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
        plt.close(fig)
        return (output_path, None)


def _create_sequential_scatter(pivot_speed, run_ids, output_dir):
    """Build and save the sequential (R1->R2, R2->R3, ...) delta scatter. Returns path or None."""
    transitions = []
    for athlete, row in pivot_speed.iterrows():
        for idx in range(len(run_ids) - 1):
            prev_run = run_ids[idx]
            next_run = run_ids[idx + 1]
            prev_speed = row.get(prev_run)
            next_speed = row.get(next_run)
            if pd.notna(prev_speed) and pd.notna(next_speed):
                transitions.append(
                    {
                        "athlete_name": athlete,
                        "prev_run": prev_run,
                        "next_run": next_run,
                        "transition": f"R{prev_run}->R{next_run}",
                        "delta_speed": float(next_speed - prev_speed),
                    }
                )
    if not transitions:
        return None
    transitions_df = pd.DataFrame(transitions)
    transition_order = [f"R{run_ids[i]}->R{run_ids[i + 1]}" for i in range(len(run_ids) - 1)]
    x_map = {name: idx for idx, name in enumerate(transition_order)}
    transitions_df["x_pos"] = transitions_df["transition"].map(x_map).astype(float)
    transitions_df["x_jitter"] = transitions_df.apply(
        lambda r: ((hash(f"{r['athlete_name']}_{r['transition']}") % 200) - 100) / 500.0, axis=1
    )
    transitions_df["x_plot"] = transitions_df["x_pos"] + transitions_df["x_jitter"]
    delta_vals = transitions_df["delta_speed"].values
    y_min, y_max = delta_vals.min(), delta_vals.max()
    y_margin = (y_max - y_min) * 0.05 or 0.2
    y_lo, y_hi = y_min - y_margin, y_max + y_margin
    fig, ax = plt.subplots(figsize=(12, 7))
    ax.axhspan(0, y_hi, alpha=0.22, color="#2ecc71", zorder=0)
    ax.axhspan(y_lo, 0, alpha=0.22, color="#e74c3c", zorder=0)
    ax.axhline(0, color="gray", linestyle="--", linewidth=1.5, alpha=0.6, zorder=1)
    point_colors = transitions_df["delta_speed"].apply(
        lambda x: "#27ae60" if x > 0 else "#c0392b" if x < 0 else "#7f8c8d"
    )
    ax.scatter(
        transitions_df["x_plot"],
        transitions_df["delta_speed"],
        s=100,
        c=list(point_colors),
        edgecolors="white",
        linewidths=1.2,
        alpha=0.95,
        zorder=3,
    )
    ax.set_ylim(y_lo, y_hi)
    ax.set_xticks(range(len(transition_order)))
    ax.set_xticklabels(transition_order, fontsize=10)
    ax.set_xlabel("Sequential Transition", fontsize=12, fontweight="bold")
    ax.set_ylabel("Speed Change (km/h)", fontsize=12, fontweight="bold")
    ax.set_title(
        "Sequential Improvement Analysis\n(Delta Max Speed Between Consecutive Runs)",
        fontsize=14,
        fontweight="bold",
        pad=18,
    )
    ax.grid(True, linestyle="-", alpha=0.3)
    legend_elements = [
        plt.Line2D([0], [0], color="gray", linestyle="--", linewidth=2, label="No Change"),
        plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#27ae60", markersize=10, label="Improved"),
        plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#c0392b", markersize=10, label="Declined"),
        plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#7f8c8d", markersize=10, label="No Change"),
    ]
    ax.legend(handles=legend_elements, loc="upper right", fontsize=10, framealpha=0.95)
    n_total = len(transitions_df)
    n_improved = int((transitions_df["delta_speed"] > 0).sum())
    n_declined = int((transitions_df["delta_speed"] < 0).sum())
    avg_improvement = transitions_df["delta_speed"].mean()
    stats_text = (
        f"Transitions: {n_total}\n"
        f"Improved: {n_improved} ({(n_improved / n_total) * 100:.1f}%)\n"
        f"Declined: {n_declined} ({(n_declined / n_total) * 100:.1f}%)\n"
        f"Avg Delta: {avg_improvement:+.2f} km/h"
    )
    ax.text(
        0.02,
        0.98,
        stats_text,
        transform=ax.transAxes,
        fontsize=10,
        verticalalignment="top",
        bbox={"boxstyle": "round,pad=0.5", "facecolor": "white", "alpha": 0.92, "edgecolor": "#bdc3c7"},
        family="monospace",
        zorder=4,
    )
    fig.tight_layout()
    out = os.path.join(output_dir, "scatter_sequential_improvement.png")
    fig.savefig(out, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
    plt.close(fig)
    print(f"Scatter plot saved: {out}")
    return out


def create_improvement_scatter(run_stats, output_dir):
    """
    Create a scatter plot of run-to-run comparison (2-run) and optionally sequential deltas (3+ runs).

    Returns (scatter_path, sequential_path_or_none).
    """
    pivot_speed = run_stats.pivot_table(
        index="athlete_name", columns="run_id", values="max_speed_kmh", aggfunc="first"
    )
    run_ids = sorted([int(col) for col in pivot_speed.columns])
    if len(run_ids) < 2:
        print("Warning: Need at least 2 runs for sequential improvement analysis.")
        return None

    r1, r2 = run_ids[0], run_ids[-1]
    # Always show Run 1 vs Run 2 scatter when we have exactly 2 runs.
    if len(run_ids) == 2:
        # Classic Run 1 vs Run 2 scatter: shaded regions (green=improved, red=declined), diagonal, colored points.
        df2 = pivot_speed[[r1, r2]].dropna(how="any")
        if not df2.empty:
            x_speed = df2[r1].values
            y_speed = df2[r2].values
            lim_min = min(x_speed.min(), y_speed.min())
            lim_max = max(x_speed.max(), y_speed.max())
            margin = (lim_max - lim_min) * 0.05 or 0.5
            x_lo, x_hi = lim_min - margin, lim_max + margin

            fig, ax = plt.subplots(figsize=(10, 10))
            # Shaded regions: improved (above diagonal), declined (below diagonal)
            x_fill = np.linspace(x_lo, x_hi, 200)
            ax.fill_between(x_fill, x_fill, x_hi, alpha=0.22, color="#2ecc71", zorder=0, label="Improved")
            ax.fill_between(x_fill, x_lo, x_fill, alpha=0.22, color="#e74c3c", zorder=0, label="Declined")
            # Diagonal (no change)
            ax.plot([x_lo, x_hi], [x_lo, x_hi], "k--", linewidth=1.5, alpha=0.6, zorder=1)
            # Points on top: solid green/red/gray
            point_colors = np.where(y_speed > x_speed, "#27ae60", np.where(y_speed < x_speed, "#c0392b", "#7f8c8d"))
            ax.scatter(
                x_speed,
                y_speed,
                s=100,
                c=list(point_colors),
                edgecolors="white",
                linewidths=1.2,
                alpha=0.95,
                zorder=3,
            )
            ax.set_xlim(x_lo, x_hi)
            ax.set_ylim(x_lo, x_hi)
            ax.set_aspect("equal", adjustable="box")
            ax.set_xlabel(f"Run {r1} - Max Speed (km/h)", fontsize=12, fontweight="bold")
            ax.set_ylabel(f"Run {r2} - Max Speed (km/h)", fontsize=12, fontweight="bold")
            ax.set_title(
                f"Improvement Analysis: Run {r1} vs Run {r2}\nPoints above diagonal = improved from Run {r1} to Run {r2}.",
                fontsize=14,
                fontweight="bold",
                pad=18,
            )
            ax.grid(True, linestyle="-", alpha=0.3)
            # Summary box (top-left)
            n_ath = len(df2)
            n_imp = int((y_speed > x_speed).sum())
            n_dec = int((y_speed < x_speed).sum())
            avg_delta = float(np.mean(y_speed - x_speed))
            stats_text = (
                f"Athletes: {n_ath}\n"
                f"Improved: {n_imp} ({100 * n_imp / n_ath:.1f}%)\n"
                f"Declined: {n_dec} ({100 * n_dec / n_ath:.1f}%)\n"
                f"Avg Change: {avg_delta:+.2f} km/h"
            )
            ax.text(
                0.04,
                0.96,
                stats_text,
                transform=ax.transAxes,
                fontsize=10,
                verticalalignment="top",
                bbox={"boxstyle": "round,pad=0.5", "facecolor": "white", "alpha": 0.92, "edgecolor": "#bdc3c7"},
                family="monospace",
                zorder=4,
            )
            # Legend bottom-right (as in reference: diagonal = No Change, green = Improved, red = Declined)
            legend_elements = [
                plt.Line2D([0], [0], color="gray", linestyle="--", linewidth=2, label="No Change"),
                plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#27ae60", markersize=10, label="Improved"),
                plt.Line2D([0], [0], marker="o", color="w", markerfacecolor="#c0392b", markersize=10, label="Declined"),
            ]
            ax.legend(handles=legend_elements, loc="lower right", fontsize=10, framealpha=0.95)
            fig.tight_layout()
            out_path = os.path.join(output_dir, "scatter_improvement_analysis.png")
            fig.savefig(out_path, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
            plt.close(fig)
            print(f"Scatter plot saved: {out_path}")
            return (out_path, None)
    elif len(run_ids) > 2:
        sequential_path = _create_sequential_scatter(pivot_speed, run_ids, output_dir)
        return (None, sequential_path)
    
    return (None, None)


def create_performance_heatmap(run_stats, output_dir):
    """
    Create a multi-run performance heatmap matrix.

    Returns the path to the saved figure.
    """
    pivot_speed = run_stats.pivot_table(
        index="athlete_name", columns="run_id", values="max_speed_kmh", aggfunc="first"
    )
    pivot_time = run_stats.pivot_table(
        index="athlete_name", columns="run_id", values="total_time_s", aggfunc="first"
    )
    if pivot_speed.empty:
        print("Warning: No data available for heatmap.")
        return None

    run_ids = sorted([int(col) for col in pivot_speed.columns])
    if not run_ids:
        print("Warning: No run IDs available for heatmap.")
        return None

    heatmap_df = pd.DataFrame(index=pivot_speed.index)

    speed_cols = []
    time_cols = []
    delta_cols = []

    for rid in run_ids:
        speed_col = f"Run {rid}\nSpeed\n(km/h)"
        time_col = f"Run {rid}\nTime\n(s)"
        heatmap_df[speed_col] = pivot_speed.get(rid, np.nan)
        heatmap_df[time_col] = pivot_time.get(rid, np.nan)
        speed_cols.append(speed_col)
        time_cols.append(time_col)

    for idx in range(len(run_ids) - 1):
        prev_run = run_ids[idx]
        next_run = run_ids[idx + 1]
        delta_col = f"Delta R{prev_run}->R{next_run}\n(km/h)"
        prev_col = f"Run {prev_run}\nSpeed\n(km/h)"
        next_col = f"Run {next_run}\nSpeed\n(km/h)"
        heatmap_df[delta_col] = heatmap_df[next_col] - heatmap_df[prev_col]
        delta_cols.append(delta_col)

    heatmap_df["Average\nSpeed\n(km/h)"] = heatmap_df[speed_cols].mean(axis=1)
    heatmap_df["Best\nSpeed\n(km/h)"] = heatmap_df[speed_cols].max(axis=1)
    heatmap_df["Best\nTime\n(s)"] = heatmap_df[time_cols].min(axis=1)
    if delta_cols:
        heatmap_df["Average\nDelta\n(km/h)"] = heatmap_df[delta_cols].mean(axis=1)

    heatmap_df = heatmap_df.sort_values("Average\nSpeed\n(km/h)", ascending=False)

    n_athletes = len(heatmap_df)
    n_cols = len(heatmap_df.columns)
    fig_height = max(8, n_athletes * 0.4 + 2)
    fig_width = max(12, n_cols * 1.5 + 3)

    fig, ax = plt.subplots(figsize=(fig_width, fig_height))

    mask = heatmap_df.isnull()

    annot_array = heatmap_df.copy()
    for col in annot_array.columns:
        annot_array[col] = annot_array[col].apply(lambda x: f"{x:.2f}" if pd.notna(x) else "")

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        sns.heatmap(
            heatmap_df,
            annot=annot_array,
            fmt="",
            cmap="YlGnBu",
            mask=mask,
            linewidths=2,
            linecolor="white",
            cbar_kws={"label": "Value", "shrink": 0.8},
            ax=ax,
            annot_kws={"size": 10, "weight": "bold"},
        )

    ax.set_title(
        "Performance Matrix Across All Runs\n(Athletes Sorted by Average Speed)",
        fontsize=14,
        fontweight="bold",
        pad=20,
    )
    ax.set_xlabel("")
    ax.set_ylabel("")

    plt.xticks(rotation=0, ha="center", fontsize=10)
    plt.yticks(rotation=0, fontsize=11)

    current_labels = [item.get_text() for item in ax.get_yticklabels()]
    ranked_labels = [f"#{i + 1} {label}" for i, label in enumerate(current_labels)]
    ax.set_yticklabels(ranked_labels, fontsize=10)

    for delta_col in delta_cols:
        col_idx = list(heatmap_df.columns).index(delta_col)
        for row_idx, (_athlete, row) in enumerate(heatmap_df.iterrows()):
            delta_val = row[delta_col]
            if pd.notna(delta_val):
                if delta_val > 0:
                    rect = plt.Rectangle(
                        (col_idx, row_idx), 1, 1, fill=True, facecolor="#2ecc71", alpha=0.3, zorder=0
                    )
                    ax.add_patch(rect)
                elif delta_val < 0:
                    rect = plt.Rectangle(
                        (col_idx, row_idx), 1, 1, fill=True, facecolor="#e74c3c", alpha=0.3, zorder=0
                    )
                    ax.add_patch(rect)

    plt.tight_layout()

    output_path = os.path.join(output_dir, "heatmap_performance_matrix.png")
    plt.savefig(output_path, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
    plt.close()

    print(f"Heatmap saved: {output_path}")
    return output_path


def calculate_team_statistics(run_stats):
    """
    Calculate comprehensive team statistics.
    Returns a dictionary with mean, min, max, std for key metrics.
    """
    stats_dict = {
        "speed": {
            "mean": run_stats["max_speed_kmh"].mean(),
            "std": run_stats["max_speed_kmh"].std(),
            "min": run_stats["max_speed_kmh"].min(),
            "max": run_stats["max_speed_kmh"].max(),
        },
        "time": {
            "mean": run_stats["total_time_s"].mean(),
            "std": run_stats["total_time_s"].std(),
            "min": run_stats["total_time_s"].min(),
            "max": run_stats["total_time_s"].max(),
        },
    }
    return stats_dict


def perform_kmeans_clustering(run_stats, n_clusters=3):
    """
    Perform K-means clustering on sprint performance data.
    Clusters are ordered by performance (1=best, 3=lowest).

    Returns: run_stats DataFrame with 'cluster' column added, cluster_summary DataFrame
    """
    if run_stats.empty:
        print("Warning: No data available. Skipping clustering.")
        return run_stats, None

    if not HAS_SKLEARN:
        print("Warning: scikit-learn not available. Skipping clustering.")
        return run_stats, None

    n_samples = len(run_stats)
    min_required = max(2, n_clusters)
    if n_samples < min_required:
        print(
            f"Warning: Insufficient samples for K-means (n={n_samples}, required>={min_required}). "
            "Skipping clustering."
        )
        return run_stats, None

    # Features for clustering
    features = run_stats[["max_speed_kmh", "total_time_s"]].copy()

    # Standardize features
    scaler = StandardScaler()
    features_scaled = scaler.fit_transform(features)

    # Perform K-means
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
    clusters = kmeans.fit_predict(features_scaled)

    # Add cluster to dataframe
    run_stats_clustered = run_stats.copy()
    run_stats_clustered["cluster_raw"] = clusters

    # Reorder clusters by performance (higher speed = better = lower cluster number)
    cluster_means = run_stats_clustered.groupby("cluster_raw")["max_speed_kmh"].mean()
    cluster_order = cluster_means.sort_values(ascending=False).index.tolist()
    cluster_mapping = {old: new + 1 for new, old in enumerate(cluster_order)}
    run_stats_clustered["cluster"] = run_stats_clustered["cluster_raw"].map(cluster_mapping)
    run_stats_clustered.drop("cluster_raw", axis=1, inplace=True)

    # Create cluster summary
    cluster_summary = (
        run_stats_clustered.groupby("cluster")
        .agg(
            {
                "max_speed_kmh": ["mean", "std", "min", "max", "count"],
                "total_time_s": ["mean", "std", "min", "max"],
            }
        )
        .round(3)
    )

    # Flatten column names
    cluster_summary.columns = ["_".join(col).strip() for col in cluster_summary.columns.values]
    cluster_summary = cluster_summary.reset_index()

    # Add cluster labels
    cluster_labels = {1: "High Performers", 2: "Medium Performers", 3: "Low Performers"}
    cluster_summary["cluster_label"] = cluster_summary["cluster"].map(cluster_labels)

    return run_stats_clustered, cluster_summary


def create_beeswarm_plot(run_stats_clustered, output_dir):
    """
    Create a beeswarm (strip) plot showing individual data points colored by cluster.

    Returns the path to the saved figure.
    """
    if "cluster" not in run_stats_clustered.columns:
        print("Warning: No cluster data available for beeswarm plot.")
        return None

    # Define cluster colors
    cluster_colors = {1: "#27ae60", 2: "#f39c12", 3: "#e74c3c"}  # Green, Orange, Red
    cluster_labels = {1: "High Performers", 2: "Medium Performers", 3: "Low Performers"}

    fig, axes = plt.subplots(1, 2, figsize=(14, 7))

    # Speed beeswarm
    ax1 = axes[0]
    for cluster in sorted(run_stats_clustered["cluster"].unique()):
        data = run_stats_clustered[run_stats_clustered["cluster"] == cluster]
        # Add jitter
        y_jitter = np.random.uniform(-0.2, 0.2, len(data))
        ax1.scatter(
            data["max_speed_kmh"],
            [cluster + j for j in y_jitter],
            s=120,
            c=cluster_colors.get(cluster, "gray"),
            alpha=0.7,
            edgecolors="white",
            linewidths=1.5,
            label=cluster_labels.get(cluster, f"Cluster {cluster}"),
        )

        # Add athlete names
        for idx, row in data.iterrows():
            ax1.annotate(
                row["athlete_name"],
                xy=(row["max_speed_kmh"], cluster + y_jitter[list(data.index).index(idx)]),
                fontsize=7,
                alpha=0.7,
                ha="left",
                va="center",
                xytext=(5, 0),
                textcoords="offset points",
            )

    ax1.set_xlabel("Max Speed (km/h)", fontsize=12, fontweight="bold")
    ax1.set_ylabel("Performance Level", fontsize=12, fontweight="bold")
    ax1.set_yticks([1, 2, 3])
    ax1.set_yticklabels(["High", "Medium", "Low"])
    ax1.set_title("Speed Distribution by Cluster", fontsize=14, fontweight="bold")
    ax1.grid(True, alpha=0.3)
    ax1.invert_yaxis()  # High performers at top

    # Time beeswarm (inverted - lower time is better)
    ax2 = axes[1]
    for cluster in sorted(run_stats_clustered["cluster"].unique()):
        data = run_stats_clustered[run_stats_clustered["cluster"] == cluster]
        y_jitter = np.random.uniform(-0.2, 0.2, len(data))
        ax2.scatter(
            data["total_time_s"],
            [cluster + j for j in y_jitter],
            s=120,
            c=cluster_colors.get(cluster, "gray"),
            alpha=0.7,
            edgecolors="white",
            linewidths=1.5,
            label=cluster_labels.get(cluster, f"Cluster {cluster}"),
        )

        for idx, row in data.iterrows():
            ax2.annotate(
                row["athlete_name"],
                xy=(row["total_time_s"], cluster + y_jitter[list(data.index).index(idx)]),
                fontsize=7,
                alpha=0.7,
                ha="left",
                va="center",
                xytext=(5, 0),
                textcoords="offset points",
            )

    ax2.set_xlabel("Total Time (s)", fontsize=12, fontweight="bold")
    ax2.set_ylabel("Performance Level", fontsize=12, fontweight="bold")
    ax2.set_yticks([1, 2, 3])
    ax2.set_yticklabels(["High", "Medium", "Low"])
    ax2.set_title("Time Distribution by Cluster", fontsize=14, fontweight="bold")
    ax2.grid(True, alpha=0.3)
    ax2.invert_yaxis()

    # Add legend
    handles, labels = ax1.get_legend_handles_labels()
    fig.legend(
        handles,
        labels,
        loc="upper center",
        ncol=3,
        fontsize=10,
        bbox_to_anchor=(0.5, 1.02),
        framealpha=0.9,
    )

    plt.suptitle(
        "Beeswarm Plot: Performance Distribution by Cluster", fontsize=16, fontweight="bold", y=1.08
    )
    plt.tight_layout()

    output_path = os.path.join(output_dir, "beeswarm_cluster_plot.png")
    plt.savefig(output_path, dpi=150, bbox_inches="tight", facecolor="white", edgecolor="none")
    plt.close()

    print(f"Beeswarm plot saved: {output_path}")
    return output_path


def calculate_zscore_table(run_stats):
    """
    Calculate Z-scores for each athlete's metrics.

    Returns: DataFrame with Z-scores and original values
    """
    zscore_df = run_stats[["athlete_name", "run_id", "max_speed_kmh", "total_time_s"]].copy()

    # Calculate Z-scores
    zscore_df["speed_zscore"] = stats.zscore(zscore_df["max_speed_kmh"])
    # For time, negative Z-score is better (faster), so we invert
    zscore_df["time_zscore"] = -stats.zscore(zscore_df["total_time_s"])

    # Calculate composite score (average of z-scores)
    zscore_df["composite_zscore"] = (zscore_df["speed_zscore"] + zscore_df["time_zscore"]) / 2

    # Sort by composite score (highest = best)
    zscore_df = zscore_df.sort_values("composite_zscore", ascending=False).reset_index(drop=True)
    zscore_df.index += 1  # 1-based ranking

    return zscore_df


def generate_zscore_html_table(zscore_df):
    """
    Generate HTML table with color-coded Z-scores.
    Green = positive (above average), Red = negative (below average)
    """

    def get_zscore_color(z):
        """Return color based on Z-score value."""
        if pd.isna(z):
            return "#ffffff"
        if z > 1.5:
            return "#1e8449"  # Dark green
        elif z > 0.5:
            return "#27ae60"  # Green
        elif z > -0.5:
            return "#f9e79f"  # Yellow
        elif z > -1.5:
            return "#e74c3c"  # Red
        else:
            return "#922b21"  # Dark red

    def get_text_color(z):
        """Return text color based on background."""
        if pd.isna(z):
            return "#000000"
        if z > 1.5 or z < -1.5:
            return "#ffffff"
        return "#000000"

    html = '<table class="zscore-table">\n'
    html += "<thead><tr>"
    html += "<th>Rank</th><th>Athlete</th><th>Run</th>"
    html += "<th>Speed (km/h)</th><th>Speed Z</th>"
    html += "<th>Time (s)</th><th>Time Z</th>"
    html += "<th>Composite Z</th>"
    html += "</tr></thead>\n<tbody>\n"

    for idx, row in zscore_df.iterrows():
        html += "<tr>"
        html += f"<td><strong>#{idx}</strong></td>"
        html += f"<td>{row['athlete_name']}</td>"
        html += f"<td>{int(row['run_id'])}</td>"
        html += f"<td>{row['max_speed_kmh']:.2f}</td>"

        # Speed Z-score cell
        speed_z = row["speed_zscore"]
        bg_color = get_zscore_color(speed_z)
        txt_color = get_text_color(speed_z)
        html += f'<td style="background-color: {bg_color}; color: {txt_color}; font-weight: bold;">{speed_z:+.2f}</td>'

        html += f"<td>{row['total_time_s']:.2f}</td>"

        # Time Z-score cell
        time_z = row["time_zscore"]
        bg_color = get_zscore_color(time_z)
        txt_color = get_text_color(time_z)
        html += f'<td style="background-color: {bg_color}; color: {txt_color}; font-weight: bold;">{time_z:+.2f}</td>'

        # Composite Z-score cell
        comp_z = row["composite_zscore"]
        bg_color = get_zscore_color(comp_z)
        txt_color = get_text_color(comp_z)
        html += f'<td style="background-color: {bg_color}; color: {txt_color}; font-weight: bold;">{comp_z:+.2f}</td>'

        html += "</tr>\n"

    html += "</tbody></table>"
    return html


def generate_cluster_html_table(run_stats_clustered):
    """
    Generate HTML table with cluster assignments and badges.
    """
    if "cluster" not in run_stats_clustered.columns:
        return ""

    cluster_colors = {1: "#27ae60", 2: "#f39c12", 3: "#e74c3c"}
    cluster_labels = {1: "High", 2: "Medium", 3: "Low"}

    # Sort by cluster then by speed
    df_sorted = run_stats_clustered.sort_values(
        ["cluster", "max_speed_kmh"], ascending=[True, False]
    ).reset_index(drop=True)

    html = '<table class="cluster-table">\n'
    html += "<thead><tr>"
    html += "<th>Athlete</th><th>Run</th><th>Speed (km/h)</th><th>Time (s)</th><th>Level</th>"
    html += "</tr></thead>\n<tbody>\n"

    for _, row in df_sorted.iterrows():
        cluster = row["cluster"]
        color = cluster_colors.get(cluster, "#95a5a6")
        label = cluster_labels.get(cluster, "N/A")

        html += "<tr>"
        html += f"<td><strong>{row['athlete_name']}</strong></td>"
        html += f"<td>{int(row['run_id'])}</td>"
        html += f"<td>{row['max_speed_kmh']:.2f}</td>"
        html += f"<td>{row['total_time_s']:.2f}</td>"
        html += f'<td><span class="cluster-badge" style="background-color: {color};">{label}</span></td>'
        html += "</tr>\n"

    html += "</tbody></table>"
    return html


def get_reference_data():
    """Returns the reference data for comparison."""
    data = {
        "Atleta": [
            "Usain Bolt (WR 100m Avg)",
            "Usain Bolt (Max Speed)",
            "Gabriel Silva (Recorde Futebol)",
        ],
        "Speed (km/h)": [37.58, 44.72, 40.30],
        "Speed (m/s)": [10.44, 12.42, 11.19],
        "Detalhes": [
            "Average speed during 9.58s WR",
            "Top momentary speed recorded",
            "Sta Clara vs Famalicão (GPS) - May 2025",
        ],
    }
    return pd.DataFrame(data)


def get_logo_base64():
    """Reads the vailá logo and returns a base64 string."""
    script_dir = Path(__file__).parent
    candidates = [
        script_dir / "images" / "vaila.png",
        script_dir / ".." / "docs" / "images" / "vaila.png",
        script_dir / ".." / ".." / "docs" / "images" / "vaila.png",
    ]

    for path in candidates:
        if os.path.exists(path):
            try:
                with open(path, "rb") as image_file:
                    return base64.b64encode(image_file.read()).decode("utf-8")
            except Exception as e:
                print(f"Error reading logo {path}: {e}")
                return None
    return None


def extract_frame(video_path, frame_number, output_path):
    """Extracts a specific frame from a video and saves it as an image."""
    if cv2 is None:
        return False

    try:
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            return False

        # Get total frames to ensure frame_number is valid
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
        if total_frames <= 0:
            return False

        if frame_number >= total_frames:
            frame_number = total_frames - 1

        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
        ret, frame = cap.read()
        cap.release()

        if ret:
            cv2.imwrite(output_path, frame)
            return True
        else:
            return False
    except Exception as e:
        print(f"Exception extracting frame from {video_path}: {e}")
        return False


def get_video_and_frame_indices(cut_data, root_data, input_dir):
    """
    Determines the best video file path and frame indices (start, end)
    to extract for a given cut.
    """

    # Strategy 1: Look for the specific CUT video file
    # Normalize path separators to ensure correct basename extraction across OSs
    raw_cut_path = cut_data.get("output_file", "")
    cut_file_name = os.path.basename(raw_cut_path.replace("\\", "/"))
    cut_video_path = os.path.join(input_dir, cut_file_name)

    if cut_file_name and os.path.exists(cut_video_path):
        frame_count = cut_data.get("frame_count", 1)
        return cut_video_path, 0, frame_count - 1

    # Strategy 2: Look for the SOURCE video file
    raw_source_path = root_data.get("source_file", "")
    source_file_name = os.path.basename(raw_source_path.replace("\\", "/"))

    candidates = [raw_source_path, os.path.join(input_dir, source_file_name)]

    source_video_path = None
    for cand in candidates:
        if cand and os.path.exists(cand):
            source_video_path = cand
            break

    if source_video_path:
        start_frame = cut_data.get("start_frame", 0)
        end_frame = cut_data.get("end_frame", 0)
        return source_video_path, start_frame, end_frame

    return None, None, None


def process_sprint_file(filepath, output_base_dir, logo_b64, mode="sprint"):
    """
    Process a single TOML file and generate individual athlete report.

    This function processes sprint data from a TOML file generated by vailá Tracker,
    calculates performance metrics, generates visualizations, and creates an HTML report.

    Parameters:
        filepath: str
            Path to the TOML file containing cut/timing data
        output_base_dir: str
            Base directory for saving output files
        logo_b64: str or None
            Base64-encoded logo image for HTML report
        mode: str
            Analysis mode - "sprint" for 20m linear or "cod" for COD 180

    Returns:
        list of dict: Database rows containing metrics for each run/section
            Keys: file_name, athlete_name, patient_id, run_id, distance_m,
                  duration_s, speed_ms, speed_kmh, acceleration_ms2, date_processed

    Output files (per athlete):
        - {basename}_analysis_{timestamp}/ directory containing:
            * {athlete}_report_sprint20m.html: Individual HTML report
            * {athlete}_Trial_N_speed.png: Speed profile plot
            * {athlete}_Trial_N_acceleration.png: Acceleration plot
            * {athlete}_Trial_N_data.xlsx: Excel data export
            * {athlete}_Trial_N_data.csv: CSV data export
            * Frame images at each distance marker (0m, 5m, 10m, 15m, 20m)
            * summary.txt: Text summary of results

    Calculations:
        - Speed (m/s and km/h) for each 5m section
        - Acceleration (m/s^2) between sections
        - Total time for 20m
        - Maximum speed and peak acceleration per run
    """
    print(f"Processing: {filepath} (Mode: {mode})")

    # helper for labels
    def get_labels(mode):
        if mode == "cod":
            return {
                "title_suffix": "(COD 180°)",
                "report_file_suffix": "_report_cod180.html",
                "0m": "0m",
                "5m": "5m",
                "10m": "10m",
                "15m": "15m",
                "20m": "20m",
            }
        else:
            return {
                "title_suffix": "(20m Linear)",
                "report_file_suffix": "_report_sprint20m.html",
                "0m": "0m",
                "5m": "5m",
                "10m": "10m",
                "15m": "15m",
                "20m": "20m",
            }

    labels_map = get_labels(mode)
    trial_label = "COD" if mode == "cod" else "Sprint"

    try:
        with open(filepath, encoding="utf-8") as f:
            data = toml.load(f)

        if "cuts" not in data:
            print(f"Skipping {filepath}: 'cuts' key not found.")
            return []

        cuts = data["cuts"]
        df = pd.DataFrame(cuts)

        if df.empty:
            print(f"Skipping {filepath}: No cuts data.")
            return []

        # Prepare output directory
        file_basename = os.path.splitext(os.path.basename(filepath))[0]
        # Extract Athlete Name: everything before the first underscore in basename
        athlete_name = file_basename.split("_")[0]

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = os.path.join(output_base_dir, f"{file_basename}_analysis_{timestamp}")
        os.makedirs(output_dir, exist_ok=True)

        # --- Calculations ---
        section_distance = 5.0  # meters
        cuts_per_run = 4

        # Stabilize cut ordering regardless of source list/index format.
        if "index" in df.columns:
            df = df.sort_values("index").reset_index(drop=True)
        else:
            df = df.reset_index(drop=True)

        cuts_total = len(df)
        runs_total = int(np.ceil(cuts_total / cuts_per_run))
        remainder = cuts_total % cuts_per_run
        if remainder != 0:
            print(
                f"Warning: {file_basename} has partial final run "
                f"({remainder}/{cuts_per_run} cuts in last run). Processing anyway."
            )

        df["run_id"] = (df.index // cuts_per_run) + 1
        df["section_in_run"] = df.groupby("run_id").cumcount() + 1
        df["distance_cumulative"] = df["section_in_run"] * section_distance
        df["speed_ms"] = section_distance / df["duration"]
        df["speed_kmh"] = df["speed_ms"] * 3.6
        df["prev_speed_ms"] = df.groupby("run_id")["speed_ms"].shift(1).fillna(0)
        df["acceleration_ms2"] = (df["speed_ms"] - df["prev_speed_ms"]) / df["duration"]
        print(
            f"Detected {cuts_total} cuts in {runs_total} run(s) for {file_basename} "
            f"(protocol: {cuts_per_run} cuts/run)."
        )

        # --- Reports Generation ---
        runs = sorted(df["run_id"].unique().tolist())

        summary_lines = [
            f"Analysis Report for {athlete_name} ({file_basename}) - {labels_map['title_suffix']}",
            "=" * 40,
            "",
        ]
        html_sections = []
        database_rows = []

        # Logo HTML
        logo_html = ""
        if logo_b64:
            logo_html = f'<div style="text-align: center; margin-bottom: 20px;"><img src="data:image/png;base64,{logo_b64}" width="120"></div>'

        for rid in runs:
            df_run = df[df["run_id"] == rid].copy()
            prefix = f"{athlete_name}_Run_{rid}"

            # Metrics
            total_time = df_run["duration"].sum()
            max_spd_kmh = df_run["speed_kmh"].max()
            max_spd_ms = df_run["speed_ms"].max()
            max_acc = df_run["acceleration_ms2"].max()

            summary_lines.extend(
                [
                    f"{trial_label} {rid}:",
                    f"  Total Time (20m): {total_time:.3f} s  [{labels_map['title_suffix']}]",
                    f"  Max Speed:        {max_spd_kmh:.3f} km/h ({max_spd_ms:.3f} m/s)",
                    f"  Peak Acceleration: {max_acc:.3f} m/s²",
                    "-" * 20,
                ]
            )

            # --- Frame Extraction Logic (0, 5, 10, 15, 20m) ---
            frame_imgs_html = ""
            if cv2:
                input_dir = os.path.dirname(filepath)
                frames_to_extract = []

                # 1. Start (0m) - Start of first cut
                if not df_run.empty:
                    first_cut_data = df_run.iloc[0].to_dict()
                    frames_to_extract.append(
                        {
                            "dist_label": labels_map.get("0m", "0m"),
                            "cut_data": first_cut_data,
                            "use_end_frame": False,
                        }
                    )

                # 2. Ends (5m, 10m, 15m, 20m...)
                # Aggregating based on cuts in the run
                current_dist = 0
                for _idx_in_run, (_row_idx, cut_row) in enumerate(df_run.iterrows()):
                    current_dist += section_distance
                    frames_to_extract.append(
                        {
                            "dist_label": labels_map.get(
                                f"{int(current_dist)}m", f"{int(current_dist)}m"
                            ),
                            "cut_data": cut_row.to_dict(),
                            "use_end_frame": True,
                        }
                    )

                valid_frames_count = 0
                for item in frames_to_extract:
                    cut_data = item["cut_data"]
                    vid_path, frame_start, frame_end = get_video_and_frame_indices(
                        cut_data, data, input_dir
                    )

                    if vid_path:
                        target_frame = frame_end if item["use_end_frame"] else frame_start
                        label = item["dist_label"]
                        img_name = f"{prefix}_{_sanitize_filename_part(label)}.png"
                        img_path = os.path.join(output_dir, img_name)

                        if extract_frame(vid_path, target_frame, img_path):
                            frame_imgs_html += f'''
                            <div style="text-align: center;">
                                <img src="{os.path.basename(img_path)}" height="150" style="border: 1px solid #ddd; border-radius: 4px; cursor: pointer;" onclick="openModal(this)" alt="{label}"><br>
                                <strong>{label}</strong>
                            </div>
                            '''
                            valid_frames_count += 1

                if valid_frames_count == 0:
                    frame_imgs_html = "<div style='color: gray; font-style: italic;'>No video frames extracted (Check video file names)</div>"

            # --- Enhanced Plotting ---
            # Speed Plot
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.lineplot(
                data=df_run,
                x="distance_cumulative",
                y="speed_kmh",
                marker="o",
                linewidth=3,
                label=athlete_name,
                ax=ax,
            )

            # Updated Reference Line (Usain Bolt - Dual)
            ax.axhline(
                y=37.58, color="gold", linestyle="--", linewidth=2, label="Bolt Avg (37.58 km/h)"
            )
            ax.axhline(
                y=44.72, color="red", linestyle=":", linewidth=2, label="Bolt Max (44.72 km/h)"
            )

            max_v_idx = df_run["speed_kmh"].idxmax()
            max_v_x = df_run.loc[max_v_idx, "distance_cumulative"]
            max_v_y = df_run.loc[max_v_idx, "speed_kmh"]
            ax.annotate(
                f"Max: {max_v_y:.1f} km/h",
                xy=(max_v_x, max_v_y),
                xytext=(max_v_x, max_v_y + 2),
                arrowprops={"facecolor": "black", "shrink": 0.05},
            )

            ax.set_title(
                f"Speed Profile {labels_map['title_suffix']} - {trial_label} {rid} ({athlete_name})",
                fontsize=16,
                fontweight="bold",
            )
            ax.set_xlabel("Distance (m)", fontsize=12)
            ax.set_ylabel("Speed (km/h)", fontsize=12)
            ax.set_ylim(bottom=0)
            ax.legend(loc="center left", bbox_to_anchor=(1.02, 0.5), borderaxespad=0.0, framealpha=0.9)
            fig.subplots_adjust(right=0.78)
            vel_plot_path = os.path.join(output_dir, f"{prefix}_speed.png")
            fig.savefig(vel_plot_path, bbox_inches="tight", dpi=150)
            plt.close(fig)

            # Acceleration Plot
            plt.figure(figsize=(10, 6))
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                bar_plot = sns.barplot(
                    data=df_run,
                    x="distance_cumulative",
                    y="acceleration_ms2",
                    hue="distance_cumulative",
                    palette="viridis",
                    legend=False,
                )

            plt.title(
                f"Acceleration per Section {labels_map['title_suffix']} - {trial_label} {rid} ({athlete_name})",
                fontsize=16,
                fontweight="bold",
            )
            plt.xlabel("Distance (m)", fontsize=12)
            plt.ylabel("Acceleration (m/s²)", fontsize=12)

            for p in bar_plot.patches:
                bar_plot.annotate(
                    f"{p.get_height():.2f}",
                    (p.get_x() + p.get_width() / 2.0, p.get_height()),
                    ha="center",
                    va="center",
                    xytext=(0, 10),
                    textcoords="offset points",
                )

            acc_plot_path = os.path.join(output_dir, f"{prefix}_acceleration.png")
            plt.savefig(acc_plot_path, bbox_inches="tight", dpi=150)
            plt.close()

            # Save CSV/Excel
            cols_export = [
                "distance_cumulative",
                "duration",
                "speed_ms",
                "speed_kmh",
                "acceleration_ms2",
            ]
            df_run[cols_export].to_excel(
                os.path.join(output_dir, f"{prefix}_data.xlsx"), index=False
            )
            df_run[cols_export].to_csv(os.path.join(output_dir, f"{prefix}_data.csv"), index=False)

            # HTML Section
            html_sections.append(f"""
            <div class="run-section">
                <h2 style="color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px;">{trial_label} {rid} Analysis</h2>

                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; background: #ecf0f1; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #7f8c8d;">Total Time (20m)</div>
                        <div style="font-size: 1.5em; font-weight: bold; color: #2c3e50;">{total_time:.3f} s</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #7f8c8d;">Max Speed</div>
                        <div style="font-size: 1.5em; font-weight: bold; color: #e74c3c;">{max_spd_kmh:.3f} km/h</div>
                        <div style="font-size: 0.8em; color: #95a5a6;">{max_spd_ms:.3f} m/s</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #7f8c8d;">Peak Acceleration</div>
                        <div style="font-size: 1.5em; font-weight: bold; color: #f39c12;">{max_acc:.3f} m/s²</div>
                    </div>
                </div>

                <div class="frames-container" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-bottom: 30px;">
                    {frame_imgs_html}
                </div>

                <div class="plots" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
                    <img src="{os.path.basename(vel_plot_path)}" width="45%" style="box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px;">
                    <img src="{os.path.basename(acc_plot_path)}" width="45%" style="box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 8px;">
                </div>

                <h3 style="margin-top: 30px; color: #34495e;">Interval Data</h3>
                {df_run[cols_export].to_html(classes="data-table", float_format="%.3f", index=False)}
                <br>
            </div>
            """)

            # Database Record
            for _idx, row in df_run.iterrows():
                cut_row = {
                    "file_name": file_basename,
                    "athlete_name": athlete_name,
                    "patient_id": athlete_name,
                    "run_id": rid,
                    "distance_m": row["distance_cumulative"],
                    "duration_s": row["duration"],
                    "speed_ms": row["speed_ms"],
                    "speed_kmh": row["speed_kmh"],
                    "acceleration_ms2": row["acceleration_ms2"],
                    "date_processed": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                }
                database_rows.append(cut_row)

        with open(os.path.join(output_dir, "summary.txt"), "w", encoding="utf-8") as f:
            f.write("\n".join(summary_lines))

        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Sprint Analysis - {athlete_name}</title>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 40px; background-color: #f9f9f9; color: #333; }}
                .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 40px; box-shadow: 0 0 20px rgba(0,0,0,0.05); border-radius: 10px; }}
                h1 {{ text-align: center; color: #2c3e50; margin-bottom: 10px; }}
                .meta-info {{ text-align: center; color: #7f8c8d; margin-bottom: 40px; }}
                .data-table {{ border-collapse: collapse; width: 100%; margin: 20px 0; font-size: 0.9em; }}
                .data-table th, .data-table td {{ border: 1px solid #e0e0e0; padding: 12px 15px; text-align: center; }}
                .data-table th {{ background-color: #3498db; color: white; text-transform: uppercase; letter-spacing: 0.03em; }}
                .data-table tr:nth-child(even) {{ background-color: #f8f9fa; }}
                .data-table tr:hover {{ background-color: #f1f1f1; }}
                hr {{ border: 0; height: 1px; background: #e0e0e0; margin: 40px 0; }}

                /* Lightbox Modal */
                .modal {{ display: none; position: fixed; z-index: 1000; padding-top: 50px; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.9); }}
                .modal-content {{ margin: auto; display: block; max-width: 90%; max-height: 90%; animation-name: zoom; animation-duration: 0.6s; }}
                @keyframes zoom {{ from {{transform:scale(0)}} to {{transform:scale(1)}} }}
                .close {{ position: absolute; top: 15px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; transition: 0.3s; cursor: pointer; }}
                .close:hover, .close:focus {{ color: #bbb; text-decoration: none; cursor: pointer; }}
            </style>
            <script>
                function openModal(img) {{
                    var modal = document.getElementById("myModal");
                    var modalImg = document.getElementById("img01");
                    modal.style.display = "block";
                    modalImg.src = img.src;
                }}
                function closeModal() {{
                    document.getElementById("myModal").style.display = "none";
                }}

                // Close on Escape key
                document.addEventListener('keydown', function(event) {{
                    if (event.key === "Escape") {{
                        closeModal();
                    }}
                }});
            </script>
        </head>
        <body>
            <div class="container">
                {logo_html}
                <h1><i>vailá</i> Sprint Analysis {labels_map["title_suffix"]} - {athlete_name}</h1>
                <div class="meta-info">
                    <p><strong>File:</strong> {file_basename} | <strong>Date:</strong> {datetime.now().strftime("%d/%m/%Y %H:%M:%S")}</p>
                </div>

                {"".join(html_sections)}

                <h2>Reference Values</h2>
                {get_reference_data().to_html(classes="data-table", index=False)}
            </div>

            <!-- Lightbox Modal -->
            <div id="myModal" class="modal" onclick="closeModal()">
              <span class="close">&times;</span>
              <img class="modal-content" id="img01">
            </div>

        </body>
        </html>
        """
        with open(
            os.path.join(output_dir, f"{file_basename}{labels_map['report_file_suffix']}"),
            "w",
            encoding="utf-8",
        ) as f:
            f.write(html_content)

        print(f"Finished {file_basename} -> Output: {output_dir}")
        return database_rows

    except Exception as e:
        print(f"Error processing {filepath}: {e}")
        import traceback

        traceback.print_exc()
        return []


def generate_general_report(all_data, output_dir, logo_b64, mode="sprint"):
    """
    Generate comprehensive team analysis report with statistics and visualizations.

    This function creates a complete team performance analysis including:
    - Consolidated database (CSV) of all runs
    - Performance rankings (by speed and time)
    - Team statistics (mean, std, min, max)
    - Visual analysis charts:
        * Multi-run evolution chart
        * Sequential improvement scatter plot
        * Multi-run performance heatmap
        * Beeswarm plot (cluster distribution)
    - K-means clustering (3 performance levels)
    - Z-score analysis table

    Parameters:
        all_data: list of dict
            Database rows from all processed athletes/runs
        output_dir: str
            Directory path for saving output files
        logo_b64: str or None
            Base64-encoded logo image for HTML report
        mode: str
            Analysis mode - "sprint" for 20m linear or "cod" for COD 180

    Output files:
        - general_report.html: Main HTML report
        - vaila_sprint_database.csv: Consolidated database
        - dumbbell_chart_performance.png
        - scatter_improvement_analysis.png
        - heatmap_performance_matrix.png
        - beeswarm_cluster_plot.png
    """
    if not all_data:
        return

    # Naming setup
    if mode == "cod":
        report_title = "COD 180° Analysis"
        db_filename = "vaila_cod180_database.csv"
        trial_label = "COD"
        trial_label_plural = "CODs"
    else:
        report_title = "Sprint Analysis"
        db_filename = "vaila_sprint_database.csv"
        trial_label = "Sprint"
        trial_label_plural = "Sprints"

    df = pd.DataFrame(all_data)

    # 1. Consolidated Database
    db_path = os.path.join(output_dir, db_filename)
    df.to_csv(db_path, index=False)
    print(f"Database generated: {db_path}")

    # 2. Ranking Summary
    run_stats = (
        df.groupby(["athlete_name", "file_name", "run_id"])
        .agg({"speed_kmh": "max", "duration_s": "sum"})
        .reset_index()
    )
    run_stats.rename(
        columns={"speed_kmh": "max_speed_kmh", "duration_s": "total_time_s"}, inplace=True
    )

    ranking_speed = run_stats.sort_values(by="max_speed_kmh", ascending=False).reset_index(
        drop=True
    )
    ranking_speed.index += 1

    ranking_time = run_stats.sort_values(by="total_time_s", ascending=True).reset_index(drop=True)
    ranking_time.index += 1

    # 3. Find top performers
    top_speed_row = run_stats.loc[run_stats["max_speed_kmh"].idxmax()]
    top_speed_athlete = top_speed_row["athlete_name"]
    top_speed_run = int(top_speed_row["run_id"])
    top_speed_value = top_speed_row["max_speed_kmh"]

    best_time_row = run_stats.loc[run_stats["total_time_s"].idxmin()]
    best_time_athlete = best_time_row["athlete_name"]
    best_time_run = int(best_time_row["run_id"])
    best_time_value = best_time_row["total_time_s"]

    # 4. Calculate team statistics
    team_stats = calculate_team_statistics(run_stats)

    # 5. Perform K-means clustering
    print("Performing K-means clustering...")
    run_stats_clustered, cluster_summary = perform_kmeans_clustering(run_stats, n_clusters=3)
    has_cluster_data = (
        cluster_summary is not None
        and not cluster_summary.empty
        and "cluster" in run_stats_clustered.columns
    )

    # 6. Calculate Z-scores
    print("Calculating Z-scores...")
    zscore_df = calculate_zscore_table(run_stats)

    # 7. Generate Enhanced Visualizations
    logo_html = ""
    if logo_b64:
        logo_html = f'<div style="text-align: center; margin-bottom: 20px;"><img src="data:image/png;base64,{logo_b64}" width="120"></div>'

    # Create all visualizations
    print("Generating enhanced visualizations...")

    # 8.1 Dumbbell Chart - Primary visualization (always Run 1 vs Run 2 when >=2 runs; + evolution if 3+)
    dumbbell_result = create_dumbbell_chart(run_stats, output_dir)
    dumbbell_path = dumbbell_result[0] if isinstance(dumbbell_result, tuple) else dumbbell_result
    evolution_path = dumbbell_result[1] if isinstance(dumbbell_result, tuple) and len(dumbbell_result) > 1 else None

    # 8.2 Improvement Scatter - Secondary (always Run 1 vs Run 2 when >=2 runs; + sequential if 3+)
    scatter_result = create_improvement_scatter(run_stats, output_dir)
    scatter_path = scatter_result[0] if isinstance(scatter_result, tuple) else scatter_result
    sequential_path = scatter_result[1] if isinstance(scatter_result, tuple) and len(scatter_result) > 1 else None

    # 8.3 Performance Heatmap - Overview visualization
    heatmap_path = create_performance_heatmap(run_stats, output_dir)

    # 7.4 Beeswarm Plot - Cluster visualization
    beeswarm_path = create_beeswarm_plot(run_stats_clustered, output_dir) if has_cluster_data else None

    # Build visualization HTML: first two cards always 2-run style (same as COD); then evolution/sequential if 3+ runs
    n_runs = int(run_stats["run_id"].nunique())
    run_ids_report = sorted(run_stats["run_id"].unique().astype(int).tolist())
    r1_report = run_ids_report[0] if run_ids_report else 1
    r2_report = run_ids_report[-1] if len(run_ids_report) > 1 else 2

    charts_html = ""
    
    if n_runs <= 2:
        if dumbbell_path:
            dumbbell_title = f"Performance Ranking: Run {r1_report} vs Run {r2_report}"
            dumbbell_desc = "Athletes sorted by best speed. Green lines = improved, Red lines = declined."
            charts_html += f'''
                <div class="chart-card">
                    <h3>{dumbbell_title}</h3>
                    <p class="chart-description">{dumbbell_desc}</p>
                    <img src="{os.path.basename(dumbbell_path)}" class="chart-img" alt="Dumbbell Chart">
                </div>
            '''
        
        if scatter_path:
            scatter_title = "Improvement Analysis"
            scatter_desc = f"Points above diagonal = improved from Run {r1_report} to Run {r2_report}."
            charts_html += f'''
                <div class="chart-card">
                    <h3>{scatter_title}</h3>
                    <p class="chart-description">{scatter_desc}</p>
                    <img src="{os.path.basename(scatter_path)}" class="chart-img" alt="Scatter Plot">
                </div>
            '''
    else:
        if dumbbell_path:
            dumbbell_title = "Multi-Run Performance Distribution"
            dumbbell_desc = "Amplitude de velocidade em todos os sprints"
            charts_html += f'''
                <div class="chart-card">
                    <h3>{dumbbell_title}</h3>
                    <p class="chart-description">{dumbbell_desc}</p>
                    <img src="{os.path.basename(dumbbell_path)}" class="chart-img" alt="Multi-Run Dot Plot">
                </div>
            '''
        
        if evolution_path:
            charts_html += f'''
                <div class="chart-card">
                    <h3>Performance Evolution Across Runs</h3>
                    <p class="chart-description">Max speed progression for each athlete across all detected runs.</p>
                    <img src="{os.path.basename(evolution_path)}" class="chart-img" alt="Evolution Chart">
                </div>
            '''
            
        if sequential_path:
            charts_html += f'''
                <div class="chart-card">
                    <h3>Sequential Improvement Analysis</h3>
                    <p class="chart-description">Each point is the speed delta between consecutive runs (R1->R2, R2->R3, ...).</p>
                    <img src="{os.path.basename(sequential_path)}" class="chart-img" alt="Sequential Scatter">
                </div>
            '''
            
    if heatmap_path:
        charts_html += f'''
            <div class="chart-card full-width">
                <h3>Multi-Run Performance Matrix</h3>
                <p class="chart-description">Complete overview across all runs. Delta columns highlight sequential improvements/declines.</p>
                <img src="{os.path.basename(heatmap_path)}" class="chart-img" alt="Heatmap">
            </div>
        '''

    beeswarm_html = ""
    if beeswarm_path:
        beeswarm_html = f'''
            <div class="chart-card full-width">
                <h3>Cluster Distribution (Beeswarm Plot)</h3>
                <p class="chart-description">Individual athlete performance colored by cluster level. Green = High, Orange = Medium, Red = Low.</p>
                <img src="{os.path.basename(beeswarm_path)}" class="chart-img" alt="Beeswarm Plot">
            </div>
        '''
    elif not has_cluster_data:
        beeswarm_html = """
            <div class="chart-card full-width">
                <h3>Cluster Distribution</h3>
                <p class="chart-description">
                    Clustering was skipped because there are not enough valid samples for reliable grouping.
                    The rest of the report remains fully available.
                </p>
            </div>
        """

    # Generate cluster and Z-score HTML tables
    cluster_table_html = (
        generate_cluster_html_table(run_stats_clustered)
        if has_cluster_data
        else "<p class='section-intro'>Cluster assignments unavailable for this dataset size.</p>"
    )
    zscore_table_html = generate_zscore_html_table(zscore_df)

    # Generate cluster summary HTML
    cluster_summary_html = ""
    if has_cluster_data:
        try:
            cluster_cards_html = ""
            card_styles = {
                1: ("high", "High Performers"),
                2: ("medium", "Medium Performers"),
                3: ("low", "Low Performers"),
            }

            for cluster_num in [1, 2, 3]:
                if cluster_num in cluster_summary["cluster"].values:
                    row = cluster_summary[cluster_summary["cluster"] == cluster_num].iloc[0]
                    style_class, label = card_styles[cluster_num]
                    cluster_cards_html += f"""
                        <div class="cluster-card {style_class}">
                            <div class="cluster-title">{label}</div>
                            <div class="cluster-stat">Avg Speed: {row["max_speed_kmh_mean"]:.2f} km/h</div>
                            <div class="cluster-stat">Avg Time: {row["total_time_s_mean"]:.2f} s</div>
                            <div class="cluster-stat">Count: {int(row["max_speed_kmh_count"])}</div>
                        </div>
                    """

            if cluster_cards_html:
                cluster_summary_html = f"""
                    <div class="cluster-summary">
                        <h4>Cluster Summary Statistics</h4>
                        <div class="cluster-cards">
                            {cluster_cards_html}
                        </div>
                    </div>
                """
        except Exception as e:
            print(f"Warning: Could not generate cluster summary HTML: {e}")
            cluster_summary_html = ""

    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>vailá - General Analysis</title>
        <meta charset="UTF-8">
        <style>
            :root {{
                --primary-color: #2c3e50;
                --accent-color: #3498db;
                --success-color: #27ae60;
                --warning-color: #f39c12;
                --danger-color: #e74c3c;
                --bg-color: #f8f9fa;
                --card-shadow: 0 4px 15px rgba(0,0,0,0.08);
            }}

            body {{
                font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
                margin: 0;
                padding: 40px;
                background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
                color: #333;
                min-height: 100vh;
            }}

            .container {{
                max-width: 1400px;
                margin: 0 auto;
                background: white;
                padding: 50px;
                box-shadow: var(--card-shadow);
                border-radius: 16px;
            }}

            h1 {{
                text-align: center;
                color: var(--primary-color);
                font-size: 2.2em;
                margin-bottom: 10px;
                letter-spacing: -0.5px;
            }}

            h2 {{
                color: var(--primary-color);
                border-bottom: 3px solid var(--accent-color);
                padding-bottom: 12px;
                margin-top: 50px;
                font-size: 1.5em;
            }}

            h3 {{
                color: var(--primary-color);
                margin: 0 0 8px 0;
                font-size: 1.2em;
            }}

            .meta-info {{
                text-align: center;
                color: #7f8c8d;
                margin-bottom: 30px;
                font-size: 1.1em;
            }}

            .stats-banner {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 20px;
                margin: 30px 0;
                padding: 25px;
                background: linear-gradient(135deg, var(--primary-color) 0%, #34495e 100%);
                border-radius: 12px;
            }}

            .stat-item {{
                text-align: center;
                color: white;
            }}

            .stat-value {{
                font-size: 2.5em;
                font-weight: bold;
                display: block;
            }}

            .stat-label {{
                font-size: 0.9em;
                opacity: 0.85;
                text-transform: uppercase;
                letter-spacing: 1px;
            }}

            .btn-group {{
                text-align: center;
                margin: 30px 0;
            }}

            .btn {{
                display: inline-block;
                padding: 14px 28px;
                background: var(--success-color);
                color: white;
                text-decoration: none;
                border-radius: 8px;
                margin: 8px;
                font-weight: 600;
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
            }}

            .btn:hover {{
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
            }}

            .btn-secondary {{
                background: var(--accent-color);
                box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
            }}

            .btn-secondary:hover {{
                box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
            }}

            .charts-grid {{
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 30px;
                margin: 40px 0;
            }}

            .chart-card {{
                background: white;
                border: 1px solid #e0e0e0;
                border-radius: 12px;
                padding: 25px;
                box-shadow: var(--card-shadow);
                transition: transform 0.3s ease, box-shadow 0.3s ease;
            }}

            .chart-card:hover {{
                transform: translateY(-5px);
                box-shadow: 0 8px 25px rgba(0,0,0,0.12);
            }}

            .chart-card.full-width {{
                grid-column: 1 / -1;
            }}

            .chart-description {{
                color: #7f8c8d;
                font-size: 0.95em;
                margin: 0 0 20px 0;
            }}

            .chart-img {{
                width: 100%;
                border-radius: 8px;
                border: 1px solid #eee;
            }}

            .data-table {{
                border-collapse: collapse;
                width: 100%;
                margin: 25px 0;
                font-size: 0.95em;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            }}

            .data-table th, .data-table td {{
                border: 1px solid #e8e8e8;
                padding: 14px 18px;
                text-align: center;
            }}

            .data-table th {{
                background: linear-gradient(135deg, var(--accent-color) 0%, #2980b9 100%);
                color: white;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                font-size: 0.85em;
            }}

            .data-table tr:nth-child(even) {{
                background-color: #f8f9fa;
            }}

            .data-table tr:hover {{
                background-color: #eef6fc;
            }}

            .rankings-grid {{
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 40px;
                margin-top: 30px;
            }}

            @media (max-width: 1000px) {{
                .charts-grid, .rankings-grid {{
                    grid-template-columns: 1fr;
                }}

                body {{
                    padding: 20px;
                }}

                .container {{
                    padding: 25px;
                }}
            }}

            .section-intro {{
                text-align: center;
                color: #666;
                max-width: 800px;
                margin: 0 auto 30px;
                line-height: 1.6;
            }}

            /* Team Statistics Styles */
            .team-stats-grid {{
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 20px;
                margin: 30px 0;
            }}

            .team-stat-card {{
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                border-radius: 10px;
                padding: 20px;
                text-align: center;
                border-left: 4px solid var(--accent-color);
            }}

            .team-stat-card.speed {{ border-left-color: var(--danger-color); }}
            .team-stat-card.time {{ border-left-color: var(--success-color); }}

            .team-stat-title {{
                font-size: 0.85em;
                color: #7f8c8d;
                text-transform: uppercase;
                letter-spacing: 1px;
                margin-bottom: 8px;
            }}

            .team-stat-value {{
                font-size: 1.8em;
                font-weight: bold;
                color: var(--primary-color);
            }}

            .team-stat-sub {{
                font-size: 0.8em;
                color: #95a5a6;
                margin-top: 4px;
            }}

            /* Cluster Styles */
            .cluster-summary {{
                margin: 30px 0;
            }}

            .cluster-cards {{
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 25px;
                margin-top: 20px;
            }}

            .cluster-card {{
                padding: 25px;
                border-radius: 12px;
                text-align: center;
                color: white;
                box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            }}

            .cluster-card.high {{
                background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            }}

            .cluster-card.medium {{
                background: linear-gradient(135deg, #f39c12 0%, #d68910 100%);
            }}

            .cluster-card.low {{
                background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            }}

            .cluster-title {{
                font-size: 1.2em;
                font-weight: bold;
                margin-bottom: 15px;
                text-transform: uppercase;
                letter-spacing: 1px;
            }}

            .cluster-stat {{
                font-size: 0.95em;
                margin: 8px 0;
                opacity: 0.95;
            }}

            .cluster-table {{
                border-collapse: collapse;
                width: 100%;
                margin: 25px 0;
                font-size: 0.95em;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            }}

            .cluster-table th, .cluster-table td {{
                border: 1px solid #e8e8e8;
                padding: 12px 15px;
                text-align: center;
            }}

            .cluster-table th {{
                background: linear-gradient(135deg, var(--primary-color) 0%, #34495e 100%);
                color: white;
                font-weight: 600;
            }}

            .cluster-table tr:nth-child(even) {{
                background-color: #f8f9fa;
            }}

            .cluster-badge {{
                display: inline-block;
                padding: 4px 12px;
                border-radius: 20px;
                color: white;
                font-size: 0.85em;
                font-weight: 600;
            }}

            /* Z-Score Table Styles */
            .zscore-table {{
                border-collapse: collapse;
                width: 100%;
                margin: 25px 0;
                font-size: 0.9em;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            }}

            .zscore-table th, .zscore-table td {{
                border: 1px solid #e8e8e8;
                padding: 12px 15px;
                text-align: center;
            }}

            .zscore-table th {{
                background: linear-gradient(135deg, #8e44ad 0%, #6c3483 100%);
                color: white;
                font-weight: 600;
            }}

            .zscore-table tr:nth-child(even) {{
                background-color: #f8f9fa;
            }}

            .zscore-legend {{
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 15px 0;
                flex-wrap: wrap;
            }}

            .zscore-legend-item {{
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.9em;
            }}

            .zscore-color-box {{
                width: 20px;
                height: 20px;
                border-radius: 4px;
            }}

            .stat-athlete {{
                font-size: 0.75em;
                opacity: 0.9;
                margin-top: 4px;
                font-weight: normal;
            }}

            @media (max-width: 1000px) {{
                .team-stats-grid {{
                    grid-template-columns: repeat(2, 1fr);
                }}
                .cluster-cards {{
                    grid-template-columns: 1fr;
                }}
            }}
        </style>
    </head>
    <body>
        <div class="container">
            {logo_html}
            <h1><i>vailá</i> {report_title}</h1>
            <p class="meta-info">General Report - Generated on {datetime.now().strftime("%d/%m/%Y at %H:%M:%S")}</p>

            <div class="stats-banner">
                <div class="stat-item">
                    <span class="stat-value">{len(set(run_stats["athlete_name"]))}</span>
                    <span class="stat-label">Athletes</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value">{run_stats.shape[0]}</span>
                    <span class="stat-label">Total {trial_label_plural}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value">{top_speed_value:.1f}</span>
                    <span class="stat-label">Top Speed (km/h)</span>
                    <span class="stat-athlete">{top_speed_athlete} ({trial_label} {top_speed_run})</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value">{best_time_value:.2f}</span>
                    <span class="stat-label">Best Time (s)</span>
                    <span class="stat-athlete">{best_time_athlete} ({trial_label} {best_time_run})</span>
                </div>
            </div>

            <div class="btn-group">
                <a href="{db_filename}" class="btn">Download Database CSV</a>
            </div>

            <h2>Team Statistics</h2>
            <p class="section-intro">
                Comprehensive team performance metrics including mean, standard deviation, minimum and maximum values.
            </p>
            <div class="team-stats-grid">
                <div class="team-stat-card speed">
                    <div class="team-stat-title">Average Speed</div>
                    <div class="team-stat-value">{team_stats["speed"]["mean"]:.2f}</div>
                    <div class="team-stat-sub">km/h</div>
                </div>
                <div class="team-stat-card speed">
                    <div class="team-stat-title">Speed Std Dev</div>
                    <div class="team-stat-value">{team_stats["speed"]["std"]:.2f}</div>
                    <div class="team-stat-sub">km/h</div>
                </div>
                <div class="team-stat-card time">
                    <div class="team-stat-title">Average Time</div>
                    <div class="team-stat-value">{team_stats["time"]["mean"]:.2f}</div>
                    <div class="team-stat-sub">seconds</div>
                </div>
                <div class="team-stat-card time">
                    <div class="team-stat-title">Time Std Dev</div>
                    <div class="team-stat-value">{team_stats["time"]["std"]:.2f}</div>
                    <div class="team-stat-sub">seconds</div>
                </div>
            </div>

            <h2>Visual Performance Analysis</h2>
            <p class="section-intro">
                Complementary visualizations to understand sprint performance:
                ranking comparison, improvement patterns, and performance matrix.
            </p>

            <div class="charts-grid">
                {charts_html}
            </div>

            <h2>K-Means Cluster Analysis (3 Levels)</h2>
            <p class="section-intro">
                Athletes classified into 3 performance levels using K-means clustering based on max speed and total time.
            </p>

            {cluster_summary_html}

            <div class="charts-grid">
                {beeswarm_html}
            </div>

            <h3>Cluster Assignments</h3>
            {cluster_table_html}

            <h2>Z-Score Analysis</h2>
            <p class="section-intro">
                Standardized scores showing how each athlete compares to the group average.
                Positive values (green) = above average, Negative values (red) = below average.
            </p>

            <div class="zscore-legend">
                <div class="zscore-legend-item">
                    <div class="zscore-color-box" style="background-color: #1e8449;"></div>
                    <span>Excellent (Z > 1.5)</span>
                </div>
                <div class="zscore-legend-item">
                    <div class="zscore-color-box" style="background-color: #27ae60;"></div>
                    <span>Good (0.5 < Z < 1.5)</span>
                </div>
                <div class="zscore-legend-item">
                    <div class="zscore-color-box" style="background-color: #f9e79f;"></div>
                    <span>Average (-0.5 < Z < 0.5)</span>
                </div>
                <div class="zscore-legend-item">
                    <div class="zscore-color-box" style="background-color: #e74c3c;"></div>
                    <span>Below Avg (-1.5 < Z < -0.5)</span>
                </div>
                <div class="zscore-legend-item">
                    <div class="zscore-color-box" style="background-color: #922b21;"></div>
                    <span>Low (Z < -1.5)</span>
                </div>
            </div>

            {zscore_table_html}

            <h2>Performance Rankings</h2>
            <div class="rankings-grid">
                <div>
                    <h3 style="color: var(--danger-color);">Ranking by Max Speed (Fastest First)</h3>
                    {ranking_speed[["athlete_name", "run_id", "max_speed_kmh", "total_time_s"]].to_html(classes="data-table", float_format="%.3f")}
                </div>
                <div>
                    <h3 style="color: var(--success-color);">Ranking by Total Time (Fastest First)</h3>
                    {ranking_time[["athlete_name", "run_id", "total_time_s", "max_speed_kmh"]].to_html(classes="data-table", float_format="%.3f")}
                </div>
            </div>

        </div>
    </body>
    </html>
    """

    with open(os.path.join(output_dir, "general_report.html"), "w", encoding="utf-8") as f:
        f.write(html_content)
    print(f"General Report generated: {os.path.join(output_dir, 'general_report.html')}")


def main():
    """
    Main entry point for vailá Sprint Analysis.

    This function orchestrates the complete sprint analysis workflow:
    1. Displays mode selection dialog (Sprint 20m or COD 180)
    2. Opens directory selection dialog for TOML files
    3. Processes all TOML files in batch
    4. Generates individual athlete reports
    5. Creates comprehensive general team report with:
       - Performance visualizations
       - K-means clustering analysis
       - Z-score analysis
       - Team statistics
    6. Optionally opens the output directory

    The function uses tkinter dialogs for user interaction and
    processes data from vailá Tracker TOML files.
    """
    print("Running vailasprint.py...")
    print("-" * 80)
    print(f"Script directory: {Path(__file__).parent}")
    print(f"Script name: {Path(__file__).name}")
    print(f"Script version: {Path(__file__).stem}")
    print(f"Script path: {Path(__file__).resolve()}")
    print(f"Script exists: {Path(__file__).exists()}")
    print(f"Script is file: {Path(__file__).is_file()}")
    print(f"Script is directory: {Path(__file__).is_dir()}")

    root = tk.Tk()
    root.withdraw()

    # --- Mode Selection ---

    # Custom Dialog for clearer options
    class ModeSelectionDialog(tk.Toplevel):
        def __init__(self, parent):
            super().__init__(parent)
            self.title("Select Analysis Mode")
            self.geometry("300x150")
            self.result = None

            tk.Label(self, text="Choose Sprint Analysis Mode:", font=("Arial", 12)).pack(pady=10)

            tk.Button(self, text="Time Sprint (20m)", width=25, command=self.set_sprint).pack(
                pady=5
            )
            tk.Button(self, text="COD 180° (20m)", width=25, command=self.set_cod).pack(
                pady=5
            )

            self.protocol("WM_DELETE_WINDOW", self.on_close)

        def set_sprint(self):
            self.result = "sprint"
            self.destroy()

        def set_cod(self):
            self.result = "cod"
            self.destroy()

        def on_close(self):
            self.result = None
            self.destroy()

    dialog = ModeSelectionDialog(root)
    root.wait_window(dialog)
    mode = dialog.result

    if not mode:
        print("Operation cancelled.")
        return

    # Removed "Coming Soon" block for COD

    # --- Sprint Mode ---

    print("Select a directory containing TOML files...")
    input_dir = filedialog.askdirectory(title="Select Directory with TOML files")

    if not input_dir:
        print("No directory selected.")
        return

    toml_files = sorted(glob.glob(os.path.join(input_dir, "*.toml")), key=lambda p: os.path.basename(p).lower())

    if not toml_files:
        messagebox.showinfo("vailá Sprint", "No .toml files found in the selected directory.")
        return

    dir_name = "vaila_cod180_reports" if mode == "cod" else "vaila_sprint_reports"

    output_base_dir = os.path.join(input_dir, dir_name)
    os.makedirs(output_base_dir, exist_ok=True)

    logo_b64 = get_logo_base64()
    if not logo_b64:
        print("Logo not found (checked standard locations). Report will be plain.")

    print(f"Found {len(toml_files)} TOML files. Processing...")

    all_database_rows = []
    count = 0
    for f in toml_files:
        rows = process_sprint_file(f, output_base_dir, logo_b64, mode=mode)
        if rows:
            all_database_rows.extend(rows)
            count += 1

    # Generate General Report & Database
    if all_database_rows:
        generate_general_report(all_database_rows, output_base_dir, logo_b64, mode=mode)
    else:
        print("No valid data processed. Skipping General Report.")

    print("=" * 80)
    print("Processing complete.")
    print(f"Processed files: {count}")
    print(f"Reports saved in: {output_base_dir}")


if __name__ == "__main__":
    main()
